diff --git a/.gitignore b/.gitignore
index 61fa39967b..a0687c79d5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,6 +2,7 @@
 /build/
 /.cache/
 /.vscode/
+/.idea/
 *.pyc
 .sdk
 .stgit-*
diff --git a/hw/scsi/Kconfig b/hw/scsi/Kconfig
index 5743ee9b4d..fcc81b304a 100644
--- a/hw/scsi/Kconfig
+++ b/hw/scsi/Kconfig
@@ -69,3 +69,8 @@ config VHOST_USER_SCSI
     default y if VIRTIO_PCI
     select VHOST_SCSI_COMMON
     depends on VIRTIO && VHOST_USER && LINUX
+
+config TEST_DISK
+    bool
+    default y
+    depends on SCSI
diff --git a/hw/scsi/meson.build b/hw/scsi/meson.build
index b874fe1ecd..a45671e646 100644
--- a/hw/scsi/meson.build
+++ b/hw/scsi/meson.build
@@ -16,6 +16,7 @@ scsi_ss.add(when: 'CONFIG_NCR710_SCSI', if_true: files('ncr53c710.c', 'lasi_ncr7
 scsi_ss.add(when: 'CONFIG_MEGASAS_SCSI_PCI', if_true: files('megasas.c'))
 scsi_ss.add(when: 'CONFIG_MPTSAS_SCSI_PCI', if_true: files('mptsas.c', 'mptconfig.c', 'mptendian.c'))
 scsi_ss.add(when: 'CONFIG_VMW_PVSCSI_SCSI_PCI', if_true: files('vmw_pvscsi.c'))
+scsi_ss.add(when: 'CONFIG_TEST_DISK', if_true: files('test_disk.c'))
 
 virtio_scsi_ss.add(files('virtio-scsi-dataplane.c'))
 virtio_scsi_ss.add(when: 'CONFIG_VHOST_SCSI', if_true: files('vhost-scsi.c'))
diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
new file mode 100644
index 0000000000..01481301fa
--- /dev/null
+++ b/hw/scsi/test_disk.c
@@ -0,0 +1,166 @@
+#include "qemu/osdep.h"
+#include "hw/scsi/test_disk.h"
+#include "hw/scsi/scsi.h"
+#include "scsi/constants.h"
+
+static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf, size_t buf_len, void* hba_private) {
+    printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
+
+    return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
+}
+
+typedef struct TestDiskReq {
+    SCSIRequest req;
+    uint8_t buf[256];
+} TestDiskReq;
+
+static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, req->dev);
+
+    uint8_t command = buf[0];
+    uint8_t* outbuf = r->buf;
+
+    if (disk->socket) {
+        qio_channel_write_all(QIO_CHANNEL(disk->socket), (char*)&command, 1, NULL);
+    }
+
+    switch (command) {
+        case 0x00:
+            printf("\tTEST_DISK: TEST UNIT READY\n");
+
+            scsi_req_complete(req, GOOD);
+            break;
+
+        case 0x12:
+            printf("\tTEST_DISK: INQUIRY\n");
+            memset(outbuf, 0, 36);
+            outbuf[0] = 0; // Direct-access block device
+            outbuf[1] = 0; // non-removable
+            outbuf[2] = 5; // SPC-3
+            outbuf[3] = 2; // response data format
+            outbuf[4] = 31; // additional length
+            memcpy(&outbuf[8], "QEMU    ", 8);
+            memcpy(&outbuf[16], "TEST_DISK       ", 16);
+
+            scsi_req_data(req, 36);
+            break;
+
+        case 0x25:
+            printf("\tTEST_DISK: READ CAPACITY (10)\n");
+
+            memset(outbuf, 0, 8);
+
+            const uint32_t block_size = 512;
+            const uint32_t total_blocks = 2097152U;
+
+            uint32_t last_lba = total_blocks - 1;
+
+            outbuf[0] = (last_lba >> 24) & 0xff;
+            outbuf[1] = (last_lba >> 16) & 0xff;
+            outbuf[2] = (last_lba >> 8) & 0xff;
+            outbuf[3] = last_lba & 0xff;
+
+            outbuf[4] = (block_size >> 24) & 0xff;
+            outbuf[5] = (block_size >> 16) & 0xff;
+            outbuf[6] = (block_size >> 8) & 0xff;
+            outbuf[7] = block_size & 0xff;
+
+            scsi_req_data(req, 8);
+
+            break;
+
+        case 0x1A:
+            printf("\tTEST_DISK: MODE SENSE (6)\n");
+
+            memset(outbuf, 0, 4);
+            outbuf[0] = 3; // length
+            outbuf[2] = 0x80; // write protection
+
+            scsi_req_data(req, 4);
+            break;
+
+        default:
+            printf("\tTEST_DISK: rejecting command 0x%02x\n", command);
+
+            scsi_req_build_sense(req, SENSE_CODE(INVALID_OPCODE));
+            scsi_req_complete(req, CHECK_CONDITION);
+
+            break;
+    }
+
+    return 0;
+}
+
+static void test_disk_read_data(SCSIRequest* req) {
+    scsi_req_complete(req, GOOD);
+}
+
+static uint8_t* test_disk_get_buf(SCSIRequest* req) {
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
+    return r->buf;
+}
+
+static const SCSIReqOps test_disk_req_ops = {
+    .size = sizeof(TestDiskReq),
+    .send_command = test_disk_send_command,
+    .read_data = test_disk_read_data,
+    .get_buf = test_disk_get_buf
+};
+
+static SCSIRequest* test_disk_alloc_req(SCSIDevice* s, uint32_t tag, uint32_t lun, uint8_t* buf, void* hba_private) {
+    return scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
+}
+
+static void test_disk_realize(SCSIDevice* dev, Error** errp) {
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, dev);
+
+    SocketAddress addr = {
+        .type = SOCKET_ADDRESS_TYPE_INET,
+        .u.inet = {
+            .host = g_strdup("127.0.0.1"),
+            .port = g_strdup("31234")
+        }
+    };
+
+    disk->socket = qio_channel_socket_new();
+
+    if (qio_channel_socket_connect_sync(disk->socket, &addr, NULL) < 0) {
+        printf("SOCKET: failed to connect\n");
+
+        object_unref(OBJECT(disk->socket));
+        disk->socket = NULL;
+    } else {
+        printf("SOCKET: connected\n");
+    }
+
+    g_free(addr.u.inet.host);
+    g_free(addr.u.inet.port);
+
+    printf("TEST_DISK: realized\n");
+}
+
+static void test_disk_class_init(ObjectClass* klass, const void* data) {
+    DeviceClass* dc = DEVICE_CLASS(klass);
+    SCSIDeviceClass* sc = SCSI_DEVICE_CLASS(klass);
+
+    sc->realize = test_disk_realize;
+    sc->parse_cdb = test_disk_parse_cdb;
+    sc->alloc_req = test_disk_alloc_req;
+
+    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
+    dc->desc = "Test SCSI Disk";
+}
+
+static const TypeInfo test_disk_info = {
+    .name = TYPE_TEST_DISK,
+    .parent = TYPE_SCSI_DEVICE,
+    .instance_size = sizeof(TestDisk),
+    .class_init = test_disk_class_init,
+};
+
+static void test_disk_register_types(void) {
+    type_register_static(&test_disk_info);
+}
+
+type_init(test_disk_register_types)
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
new file mode 100644
index 0000000000..c6a07db5dd
--- /dev/null
+++ b/include/hw/scsi/test_disk.h
@@ -0,0 +1,16 @@
+#ifndef HW_SCSI_TEST_DISK_H
+#define HW_SCSI_TEST_DISK_H
+
+#include "hw/scsi/scsi.h"
+#include "io/channel-socket.h"
+#include "qom/object.h"
+
+#define TYPE_TEST_DISK "test_disk"
+OBJECT_DECLARE_SIMPLE_TYPE(TestDisk, TEST_DISK)
+
+struct TestDisk {
+    SCSIDevice parent_obj;
+    QIOChannelSocket* socket;
+};
+
+#endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
