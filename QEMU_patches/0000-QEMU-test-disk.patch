From 262ff0d0d6db6e6404265a494215fd3785bb999e Mon Sep 17 00:00:00 2001
X-Base-Commit-Hash: 2339d0a1cfac6ecc667e6e062a593865c1541c35
X-Base-Commit-Hash: 2339d0a1cfac6ecc667e6e062a593865c1541c35
X-Base-Commit-Hash: 2339d0a1cfac6ecc667e6e062a593865c1541c35
X-Base-Commit-Hash: 2339d0a1cfac6ecc667e6e062a593865c1541c35
X-Base-Commit-Hash: 2339d0a1cfac6ecc667e6e062a593865c1541c35
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Tue, 13 Jan 2026 19:53:51 +0300
Subject: [PATCH 1/4] [ADD] Add test scsi disk

---
 .gitignore                  |  1 +
 hw/scsi/Kconfig             |  5 +++++
 hw/scsi/meson.build         |  1 +
 hw/scsi/test_disk.c         | 38 +++++++++++++++++++++++++++++++++++++
 include/hw/scsi/test_disk.h | 15 +++++++++++++++
 5 files changed, 60 insertions(+)
 create mode 100644 hw/scsi/test_disk.c
 create mode 100644 include/hw/scsi/test_disk.h

diff --git a/.gitignore b/.gitignore
index 61fa39967b..a0687c79d5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,6 +2,7 @@
 /build/
 /.cache/
 /.vscode/
+/.idea/
 *.pyc
 .sdk
 .stgit-*
diff --git a/hw/scsi/Kconfig b/hw/scsi/Kconfig
index 5743ee9b4d..fcc81b304a 100644
--- a/hw/scsi/Kconfig
+++ b/hw/scsi/Kconfig
@@ -69,3 +69,8 @@ config VHOST_USER_SCSI
     default y if VIRTIO_PCI
     select VHOST_SCSI_COMMON
     depends on VIRTIO && VHOST_USER && LINUX
+
+config TEST_DISK
+    bool
+    default y
+    depends on SCSI
diff --git a/hw/scsi/meson.build b/hw/scsi/meson.build
index b874fe1ecd..a45671e646 100644
--- a/hw/scsi/meson.build
+++ b/hw/scsi/meson.build
@@ -16,6 +16,7 @@ scsi_ss.add(when: 'CONFIG_NCR710_SCSI', if_true: files('ncr53c710.c', 'lasi_ncr7
 scsi_ss.add(when: 'CONFIG_MEGASAS_SCSI_PCI', if_true: files('megasas.c'))
 scsi_ss.add(when: 'CONFIG_MPTSAS_SCSI_PCI', if_true: files('mptsas.c', 'mptconfig.c', 'mptendian.c'))
 scsi_ss.add(when: 'CONFIG_VMW_PVSCSI_SCSI_PCI', if_true: files('vmw_pvscsi.c'))
+scsi_ss.add(when: 'CONFIG_TEST_DISK', if_true: files('test_disk.c'))
 
 virtio_scsi_ss.add(files('virtio-scsi-dataplane.c'))
 virtio_scsi_ss.add(when: 'CONFIG_VHOST_SCSI', if_true: files('vhost-scsi.c'))
diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
new file mode 100644
index 0000000000..a8c774182b
--- /dev/null
+++ b/hw/scsi/test_disk.c
@@ -0,0 +1,38 @@
+#include "qemu/osdep.h"
+#include "hw/scsi/test_disk.h"
+#include "hw/scsi/scsi.h"
+#include "qapi/error.h"
+
+static int test_disk_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf, size_t buf_len, void *hba_private) {
+    printf("MySCSIDevice: Received CDB command 0x%02x\n", buf[0]);
+
+    return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
+}
+
+static void test_disk_realize(SCSIDevice *dev, Error **errp) {
+    printf("MySCSIDevice: Device realized (initialized)\n");
+}
+
+static void test_disk_class_init(ObjectClass *klass, const void *data) {
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    SCSIDeviceClass *sc = SCSI_DEVICE_CLASS(klass);
+
+    sc->realize = test_disk_realize;
+    sc->parse_cdb = test_disk_parse_cdb;
+
+    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
+    dc->desc = "Test SCSI Disk";
+}
+
+static const TypeInfo test_disk_info = {
+    .name = TYPE_TEST_DISK,
+    .parent = TYPE_SCSI_DEVICE,
+    .instance_size = sizeof(TestDisk),
+    .class_init = test_disk_class_init,
+};
+
+static void test_disk_register_types(void) {
+    type_register_static(&test_disk_info);
+}
+
+type_init(test_disk_register_types)
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
new file mode 100644
index 0000000000..be2f7ccbd3
--- /dev/null
+++ b/include/hw/scsi/test_disk.h
@@ -0,0 +1,15 @@
+#ifndef HW_SCSI_TEST_DISK_H
+#define HW_SCSI_TEST_DISK_H
+
+#include "hw/scsi/scsi.h"
+#include "qom/object.h"
+
+#define TYPE_TEST_DISK "test_disk"
+OBJECT_DECLARE_SIMPLE_TYPE(TestDisk, TEST_DISK)
+
+struct TestDisk {
+    SCSIDevice parent_obj;
+};
+
+#endif //HW_SCSI_TEST_DISK_H
+./
\ No newline at end of file
-- 
2.52.0


From 6e84f169872c8bd39c363569a22094ad264de2a3 Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Thu, 15 Jan 2026 18:12:16 +0300
Subject: [PATCH 2/4] [ADD] Add basic request handling

---
 hw/scsi/test_disk.c         | 104 +++++++++++++++++++++++++++++++++++-
 include/hw/scsi/test_disk.h |   3 +-
 2 files changed, 103 insertions(+), 4 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index a8c774182b..42a4f220f1 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -2,15 +2,114 @@
 #include "hw/scsi/test_disk.h"
 #include "hw/scsi/scsi.h"
 #include "qapi/error.h"
+#include "scsi/constants.h"
 
 static int test_disk_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf, size_t buf_len, void *hba_private) {
-    printf("MySCSIDevice: Received CDB command 0x%02x\n", buf[0]);
+    printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
 
     return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
 }
 
+typedef struct TestDiskReq {
+    SCSIRequest req;
+    uint8_t buf[256];
+} TestDiskReq;
+
+static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
+    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+    uint8_t command = buf[0];
+    uint8_t* outbuf = r->buf;
+
+    switch (command) {
+        case 0x00:
+            printf("\tTEST_DISK: TEST UNIT READY\n");
+
+            scsi_req_complete(req, GOOD);
+            break;
+
+        case 0x12:
+            printf("\tTEST_DISK: INQUIRY\n");
+            memset(outbuf, 0, 36);
+            outbuf[0] = 0;   // Direct-access block device
+            outbuf[1] = 0;   // non-removable
+            outbuf[2] = 5;   // SPC-3
+            outbuf[3] = 2;   // response data format
+            outbuf[4] = 31;  // additional length
+            memcpy(&outbuf[8],  "QEMU    ", 8);
+            memcpy(&outbuf[16], "TEST_DISK       ", 16);
+
+            scsi_req_data(req, 36);
+            break;
+
+        case 0x25:
+            printf("\tTEST_DISK: READ CAPACITY (10)\n");
+
+            memset(outbuf, 0, 8);
+
+            const uint32_t block_size = 512;
+            const uint32_t total_blocks = 2097152U;
+
+            uint32_t last_lba = total_blocks - 1;
+
+            outbuf[0] = (last_lba >> 24) & 0xff;
+            outbuf[1] = (last_lba >> 16) & 0xff;
+            outbuf[2] = (last_lba >> 8) & 0xff;
+            outbuf[3] = last_lba & 0xff;
+            
+            outbuf[4] = (block_size >> 24) & 0xff;
+            outbuf[5] = (block_size >> 16) & 0xff;
+            outbuf[6] = (block_size >> 8) & 0xff;
+            outbuf[7] = block_size & 0xff;
+            
+            scsi_req_data(req, 8);
+
+            break;
+
+        case 0x1A:
+            printf("\tTEST_DISK: MODE SENSE (6)\n");
+
+            memset(outbuf, 0, 4);
+            outbuf[0] = 3;     // length
+            outbuf[2] = 0x80;  // write protection
+
+            scsi_req_data(req, 4);
+            break;
+
+        default:
+            printf("\tTEST_DISK: rejecting command 0x%02x\n", command);
+
+            scsi_req_build_sense(req, SENSE_CODE(INVALID_OPCODE));
+            scsi_req_complete(req, CHECK_CONDITION);
+
+            break;
+    }
+
+    return 0;
+}
+
+static void test_disk_read_data(SCSIRequest *req) {
+    scsi_req_complete(req, GOOD);
+}
+
+static uint8_t* test_disk_get_buf(SCSIRequest *req)
+{
+    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+    return r->buf;
+}
+
+static const SCSIReqOps test_disk_req_ops = {
+    .size = sizeof(TestDiskReq),
+    .send_command = test_disk_send_command,
+    .read_data = test_disk_read_data,
+    .get_buf = test_disk_get_buf
+};
+
+static SCSIRequest* test_disk_alloc_req(SCSIDevice *s, uint32_t tag, uint32_t lun, uint8_t *buf, void *hba_private) {
+    return scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
+}
+
 static void test_disk_realize(SCSIDevice *dev, Error **errp) {
-    printf("MySCSIDevice: Device realized (initialized)\n");
+    printf("TEST_DISK: realized\n");
 }
 
 static void test_disk_class_init(ObjectClass *klass, const void *data) {
@@ -19,6 +118,7 @@ static void test_disk_class_init(ObjectClass *klass, const void *data) {
 
     sc->realize = test_disk_realize;
     sc->parse_cdb = test_disk_parse_cdb;
+    sc->alloc_req = test_disk_alloc_req;
 
     set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
     dc->desc = "Test SCSI Disk";
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
index be2f7ccbd3..ac9e278372 100644
--- a/include/hw/scsi/test_disk.h
+++ b/include/hw/scsi/test_disk.h
@@ -11,5 +11,4 @@ struct TestDisk {
     SCSIDevice parent_obj;
 };
 
-#endif //HW_SCSI_TEST_DISK_H
-./
\ No newline at end of file
+#endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
-- 
2.52.0


From 30039cdfd25a3706d3736a6fba1630c9125143e0 Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Tue, 20 Jan 2026 20:24:58 +0300
Subject: [PATCH 3/4] [ADD] Add socket connection with server

---
 hw/scsi/test_disk.c         | 72 +++++++++++++++++++++++++------------
 include/hw/scsi/test_disk.h |  2 ++
 2 files changed, 52 insertions(+), 22 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index 42a4f220f1..01481301fa 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -1,10 +1,9 @@
 #include "qemu/osdep.h"
 #include "hw/scsi/test_disk.h"
 #include "hw/scsi/scsi.h"
-#include "qapi/error.h"
 #include "scsi/constants.h"
 
-static int test_disk_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf, size_t buf_len, void *hba_private) {
+static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf, size_t buf_len, void* hba_private) {
     printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
 
     return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
@@ -16,10 +15,16 @@ typedef struct TestDiskReq {
 } TestDiskReq;
 
 static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
-    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, req->dev);
+
     uint8_t command = buf[0];
     uint8_t* outbuf = r->buf;
 
+    if (disk->socket) {
+        qio_channel_write_all(QIO_CHANNEL(disk->socket), (char*)&command, 1, NULL);
+    }
+
     switch (command) {
         case 0x00:
             printf("\tTEST_DISK: TEST UNIT READY\n");
@@ -30,12 +35,12 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
         case 0x12:
             printf("\tTEST_DISK: INQUIRY\n");
             memset(outbuf, 0, 36);
-            outbuf[0] = 0;   // Direct-access block device
-            outbuf[1] = 0;   // non-removable
-            outbuf[2] = 5;   // SPC-3
-            outbuf[3] = 2;   // response data format
-            outbuf[4] = 31;  // additional length
-            memcpy(&outbuf[8],  "QEMU    ", 8);
+            outbuf[0] = 0; // Direct-access block device
+            outbuf[1] = 0; // non-removable
+            outbuf[2] = 5; // SPC-3
+            outbuf[3] = 2; // response data format
+            outbuf[4] = 31; // additional length
+            memcpy(&outbuf[8], "QEMU    ", 8);
             memcpy(&outbuf[16], "TEST_DISK       ", 16);
 
             scsi_req_data(req, 36);
@@ -55,12 +60,12 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             outbuf[1] = (last_lba >> 16) & 0xff;
             outbuf[2] = (last_lba >> 8) & 0xff;
             outbuf[3] = last_lba & 0xff;
-            
+
             outbuf[4] = (block_size >> 24) & 0xff;
             outbuf[5] = (block_size >> 16) & 0xff;
             outbuf[6] = (block_size >> 8) & 0xff;
             outbuf[7] = block_size & 0xff;
-            
+
             scsi_req_data(req, 8);
 
             break;
@@ -69,8 +74,8 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             printf("\tTEST_DISK: MODE SENSE (6)\n");
 
             memset(outbuf, 0, 4);
-            outbuf[0] = 3;     // length
-            outbuf[2] = 0x80;  // write protection
+            outbuf[0] = 3; // length
+            outbuf[2] = 0x80; // write protection
 
             scsi_req_data(req, 4);
             break;
@@ -87,13 +92,12 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
     return 0;
 }
 
-static void test_disk_read_data(SCSIRequest *req) {
+static void test_disk_read_data(SCSIRequest* req) {
     scsi_req_complete(req, GOOD);
 }
 
-static uint8_t* test_disk_get_buf(SCSIRequest *req)
-{
-    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+static uint8_t* test_disk_get_buf(SCSIRequest* req) {
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
     return r->buf;
 }
 
@@ -104,17 +108,41 @@ static const SCSIReqOps test_disk_req_ops = {
     .get_buf = test_disk_get_buf
 };
 
-static SCSIRequest* test_disk_alloc_req(SCSIDevice *s, uint32_t tag, uint32_t lun, uint8_t *buf, void *hba_private) {
+static SCSIRequest* test_disk_alloc_req(SCSIDevice* s, uint32_t tag, uint32_t lun, uint8_t* buf, void* hba_private) {
     return scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
 }
 
-static void test_disk_realize(SCSIDevice *dev, Error **errp) {
+static void test_disk_realize(SCSIDevice* dev, Error** errp) {
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, dev);
+
+    SocketAddress addr = {
+        .type = SOCKET_ADDRESS_TYPE_INET,
+        .u.inet = {
+            .host = g_strdup("127.0.0.1"),
+            .port = g_strdup("31234")
+        }
+    };
+
+    disk->socket = qio_channel_socket_new();
+
+    if (qio_channel_socket_connect_sync(disk->socket, &addr, NULL) < 0) {
+        printf("SOCKET: failed to connect\n");
+
+        object_unref(OBJECT(disk->socket));
+        disk->socket = NULL;
+    } else {
+        printf("SOCKET: connected\n");
+    }
+
+    g_free(addr.u.inet.host);
+    g_free(addr.u.inet.port);
+
     printf("TEST_DISK: realized\n");
 }
 
-static void test_disk_class_init(ObjectClass *klass, const void *data) {
-    DeviceClass *dc = DEVICE_CLASS(klass);
-    SCSIDeviceClass *sc = SCSI_DEVICE_CLASS(klass);
+static void test_disk_class_init(ObjectClass* klass, const void* data) {
+    DeviceClass* dc = DEVICE_CLASS(klass);
+    SCSIDeviceClass* sc = SCSI_DEVICE_CLASS(klass);
 
     sc->realize = test_disk_realize;
     sc->parse_cdb = test_disk_parse_cdb;
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
index ac9e278372..c6a07db5dd 100644
--- a/include/hw/scsi/test_disk.h
+++ b/include/hw/scsi/test_disk.h
@@ -2,6 +2,7 @@
 #define HW_SCSI_TEST_DISK_H
 
 #include "hw/scsi/scsi.h"
+#include "io/channel-socket.h"
 #include "qom/object.h"
 
 #define TYPE_TEST_DISK "test_disk"
@@ -9,6 +10,7 @@ OBJECT_DECLARE_SIMPLE_TYPE(TestDisk, TEST_DISK)
 
 struct TestDisk {
     SCSIDevice parent_obj;
+    QIOChannelSocket* socket;
 };
 
 #endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
-- 
2.52.0


From bdcc99c3fef44623ab515b5fc3db93758ff61c22 Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Wed, 21 Jan 2026 20:00:40 +0300
Subject: [PATCH 4/4] [ADD] Add read command handler with delay

---
 hw/scsi/test_disk.c | 69 ++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 65 insertions(+), 4 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index 01481301fa..a4bf98bf5f 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -3,6 +3,9 @@
 #include "hw/scsi/scsi.h"
 #include "scsi/constants.h"
 
+// block size * max blocks
+#define MAX_READ_XFER_SIZE (512 * 2048) // 1MB
+
 static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf, size_t buf_len, void* hba_private) {
     printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
 
@@ -11,9 +14,25 @@ static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf,
 
 typedef struct TestDiskReq {
     SCSIRequest req;
-    uint8_t buf[256];
+    QEMUTimer* timer;
+    int len;
+    uint8_t buf[MAX_READ_XFER_SIZE];
 } TestDiskReq;
 
+static void test_disk_read_callback(void* opaque) {
+    printf("CALLBACK: from READ command\n");
+
+    TestDiskReq* r = opaque;
+
+    uint8_t* outbuf = r->buf;
+    memset(outbuf, 0, r->len);
+
+    scsi_req_data(&r->req, r->len);
+
+    timer_free(r->timer);
+    r->timer = NULL;
+}
+
 static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
     TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
     TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, req->dev);
@@ -52,7 +71,7 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             memset(outbuf, 0, 8);
 
             const uint32_t block_size = 512;
-            const uint32_t total_blocks = 2097152U;
+            const uint32_t total_blocks = 2048U;
 
             uint32_t last_lba = total_blocks - 1;
 
@@ -67,7 +86,6 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             outbuf[7] = block_size & 0xff;
 
             scsi_req_data(req, 8);
-
             break;
 
         case 0x1A:
@@ -80,12 +98,52 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             scsi_req_data(req, 4);
             break;
 
+        case 0x5A:
+            printf("\tTEST_DISK: MODE SENSE (10)\n");
+            memset(outbuf, 0, 8);
+
+            outbuf[0] = 0;
+            outbuf[1] = 6;
+
+            outbuf[3] = 0x80;
+
+            scsi_req_data(req, 8);
+            break;
+
+        case 0x08:
+        case 0x28:
+            int read_type = command == 0x08 ? 6 : 10;
+            printf("\tTEST_DISK: READ (%d)\n", read_type);
+
+            int target_len = (int)req->cmd.xfer;
+            printf("\tTARGET_LEN: %d\n", target_len);
+
+            if (target_len == 0) {
+                scsi_req_complete(req, GOOD);
+                break;
+            }
+
+            if (target_len > sizeof(r->buf)) {
+                printf("\tTEST_DISK: error - request too big\n");
+
+                scsi_req_build_sense(req, SENSE_CODE(LBA_OUT_OF_RANGE));
+                scsi_req_complete(req, CHECK_CONDITION);
+                break;
+            }
+
+            r->len = target_len;
+            r->timer = timer_new_ms(QEMU_CLOCK_REALTIME, test_disk_read_callback, r);
+
+            uint8_t delay_ms = 0;
+            timer_mod(r->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + delay_ms);
+
+            return 0;
+
         default:
             printf("\tTEST_DISK: rejecting command 0x%02x\n", command);
 
             scsi_req_build_sense(req, SENSE_CODE(INVALID_OPCODE));
             scsi_req_complete(req, CHECK_CONDITION);
-
             break;
     }
 
@@ -113,6 +171,9 @@ static SCSIRequest* test_disk_alloc_req(SCSIDevice* s, uint32_t tag, uint32_t lu
 }
 
 static void test_disk_realize(SCSIDevice* dev, Error** errp) {
+    dev->type = TYPE_DISK;
+    dev->blocksize = 512;
+
     TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, dev);
 
     SocketAddress addr = {
-- 
2.52.0

From 262ff0d0d6db6e6404265a494215fd3785bb999e Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Tue, 13 Jan 2026 19:53:51 +0300
Subject: [PATCH 1/5] [ADD] Add test scsi disk

---
 .gitignore                  |  1 +
 hw/scsi/Kconfig             |  5 +++++
 hw/scsi/meson.build         |  1 +
 hw/scsi/test_disk.c         | 38 +++++++++++++++++++++++++++++++++++++
 include/hw/scsi/test_disk.h | 15 +++++++++++++++
 5 files changed, 60 insertions(+)
 create mode 100644 hw/scsi/test_disk.c
 create mode 100644 include/hw/scsi/test_disk.h

diff --git a/.gitignore b/.gitignore
index 61fa39967b..a0687c79d5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,6 +2,7 @@
 /build/
 /.cache/
 /.vscode/
+/.idea/
 *.pyc
 .sdk
 .stgit-*
diff --git a/hw/scsi/Kconfig b/hw/scsi/Kconfig
index 5743ee9b4d..fcc81b304a 100644
--- a/hw/scsi/Kconfig
+++ b/hw/scsi/Kconfig
@@ -69,3 +69,8 @@ config VHOST_USER_SCSI
     default y if VIRTIO_PCI
     select VHOST_SCSI_COMMON
     depends on VIRTIO && VHOST_USER && LINUX
+
+config TEST_DISK
+    bool
+    default y
+    depends on SCSI
diff --git a/hw/scsi/meson.build b/hw/scsi/meson.build
index b874fe1ecd..a45671e646 100644
--- a/hw/scsi/meson.build
+++ b/hw/scsi/meson.build
@@ -16,6 +16,7 @@ scsi_ss.add(when: 'CONFIG_NCR710_SCSI', if_true: files('ncr53c710.c', 'lasi_ncr7
 scsi_ss.add(when: 'CONFIG_MEGASAS_SCSI_PCI', if_true: files('megasas.c'))
 scsi_ss.add(when: 'CONFIG_MPTSAS_SCSI_PCI', if_true: files('mptsas.c', 'mptconfig.c', 'mptendian.c'))
 scsi_ss.add(when: 'CONFIG_VMW_PVSCSI_SCSI_PCI', if_true: files('vmw_pvscsi.c'))
+scsi_ss.add(when: 'CONFIG_TEST_DISK', if_true: files('test_disk.c'))
 
 virtio_scsi_ss.add(files('virtio-scsi-dataplane.c'))
 virtio_scsi_ss.add(when: 'CONFIG_VHOST_SCSI', if_true: files('vhost-scsi.c'))
diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
new file mode 100644
index 0000000000..a8c774182b
--- /dev/null
+++ b/hw/scsi/test_disk.c
@@ -0,0 +1,38 @@
+#include "qemu/osdep.h"
+#include "hw/scsi/test_disk.h"
+#include "hw/scsi/scsi.h"
+#include "qapi/error.h"
+
+static int test_disk_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf, size_t buf_len, void *hba_private) {
+    printf("MySCSIDevice: Received CDB command 0x%02x\n", buf[0]);
+
+    return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
+}
+
+static void test_disk_realize(SCSIDevice *dev, Error **errp) {
+    printf("MySCSIDevice: Device realized (initialized)\n");
+}
+
+static void test_disk_class_init(ObjectClass *klass, const void *data) {
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    SCSIDeviceClass *sc = SCSI_DEVICE_CLASS(klass);
+
+    sc->realize = test_disk_realize;
+    sc->parse_cdb = test_disk_parse_cdb;
+
+    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
+    dc->desc = "Test SCSI Disk";
+}
+
+static const TypeInfo test_disk_info = {
+    .name = TYPE_TEST_DISK,
+    .parent = TYPE_SCSI_DEVICE,
+    .instance_size = sizeof(TestDisk),
+    .class_init = test_disk_class_init,
+};
+
+static void test_disk_register_types(void) {
+    type_register_static(&test_disk_info);
+}
+
+type_init(test_disk_register_types)
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
new file mode 100644
index 0000000000..be2f7ccbd3
--- /dev/null
+++ b/include/hw/scsi/test_disk.h
@@ -0,0 +1,15 @@
+#ifndef HW_SCSI_TEST_DISK_H
+#define HW_SCSI_TEST_DISK_H
+
+#include "hw/scsi/scsi.h"
+#include "qom/object.h"
+
+#define TYPE_TEST_DISK "test_disk"
+OBJECT_DECLARE_SIMPLE_TYPE(TestDisk, TEST_DISK)
+
+struct TestDisk {
+    SCSIDevice parent_obj;
+};
+
+#endif //HW_SCSI_TEST_DISK_H
+./
\ No newline at end of file
-- 
2.52.0


From 6e84f169872c8bd39c363569a22094ad264de2a3 Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Thu, 15 Jan 2026 18:12:16 +0300
Subject: [PATCH 2/5] [ADD] Add basic request handling

---
 hw/scsi/test_disk.c         | 104 +++++++++++++++++++++++++++++++++++-
 include/hw/scsi/test_disk.h |   3 +-
 2 files changed, 103 insertions(+), 4 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index a8c774182b..42a4f220f1 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -2,15 +2,114 @@
 #include "hw/scsi/test_disk.h"
 #include "hw/scsi/scsi.h"
 #include "qapi/error.h"
+#include "scsi/constants.h"
 
 static int test_disk_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf, size_t buf_len, void *hba_private) {
-    printf("MySCSIDevice: Received CDB command 0x%02x\n", buf[0]);
+    printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
 
     return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
 }
 
+typedef struct TestDiskReq {
+    SCSIRequest req;
+    uint8_t buf[256];
+} TestDiskReq;
+
+static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
+    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+    uint8_t command = buf[0];
+    uint8_t* outbuf = r->buf;
+
+    switch (command) {
+        case 0x00:
+            printf("\tTEST_DISK: TEST UNIT READY\n");
+
+            scsi_req_complete(req, GOOD);
+            break;
+
+        case 0x12:
+            printf("\tTEST_DISK: INQUIRY\n");
+            memset(outbuf, 0, 36);
+            outbuf[0] = 0;   // Direct-access block device
+            outbuf[1] = 0;   // non-removable
+            outbuf[2] = 5;   // SPC-3
+            outbuf[3] = 2;   // response data format
+            outbuf[4] = 31;  // additional length
+            memcpy(&outbuf[8],  "QEMU    ", 8);
+            memcpy(&outbuf[16], "TEST_DISK       ", 16);
+
+            scsi_req_data(req, 36);
+            break;
+
+        case 0x25:
+            printf("\tTEST_DISK: READ CAPACITY (10)\n");
+
+            memset(outbuf, 0, 8);
+
+            const uint32_t block_size = 512;
+            const uint32_t total_blocks = 2097152U;
+
+            uint32_t last_lba = total_blocks - 1;
+
+            outbuf[0] = (last_lba >> 24) & 0xff;
+            outbuf[1] = (last_lba >> 16) & 0xff;
+            outbuf[2] = (last_lba >> 8) & 0xff;
+            outbuf[3] = last_lba & 0xff;
+            
+            outbuf[4] = (block_size >> 24) & 0xff;
+            outbuf[5] = (block_size >> 16) & 0xff;
+            outbuf[6] = (block_size >> 8) & 0xff;
+            outbuf[7] = block_size & 0xff;
+            
+            scsi_req_data(req, 8);
+
+            break;
+
+        case 0x1A:
+            printf("\tTEST_DISK: MODE SENSE (6)\n");
+
+            memset(outbuf, 0, 4);
+            outbuf[0] = 3;     // length
+            outbuf[2] = 0x80;  // write protection
+
+            scsi_req_data(req, 4);
+            break;
+
+        default:
+            printf("\tTEST_DISK: rejecting command 0x%02x\n", command);
+
+            scsi_req_build_sense(req, SENSE_CODE(INVALID_OPCODE));
+            scsi_req_complete(req, CHECK_CONDITION);
+
+            break;
+    }
+
+    return 0;
+}
+
+static void test_disk_read_data(SCSIRequest *req) {
+    scsi_req_complete(req, GOOD);
+}
+
+static uint8_t* test_disk_get_buf(SCSIRequest *req)
+{
+    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+    return r->buf;
+}
+
+static const SCSIReqOps test_disk_req_ops = {
+    .size = sizeof(TestDiskReq),
+    .send_command = test_disk_send_command,
+    .read_data = test_disk_read_data,
+    .get_buf = test_disk_get_buf
+};
+
+static SCSIRequest* test_disk_alloc_req(SCSIDevice *s, uint32_t tag, uint32_t lun, uint8_t *buf, void *hba_private) {
+    return scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
+}
+
 static void test_disk_realize(SCSIDevice *dev, Error **errp) {
-    printf("MySCSIDevice: Device realized (initialized)\n");
+    printf("TEST_DISK: realized\n");
 }
 
 static void test_disk_class_init(ObjectClass *klass, const void *data) {
@@ -19,6 +118,7 @@ static void test_disk_class_init(ObjectClass *klass, const void *data) {
 
     sc->realize = test_disk_realize;
     sc->parse_cdb = test_disk_parse_cdb;
+    sc->alloc_req = test_disk_alloc_req;
 
     set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
     dc->desc = "Test SCSI Disk";
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
index be2f7ccbd3..ac9e278372 100644
--- a/include/hw/scsi/test_disk.h
+++ b/include/hw/scsi/test_disk.h
@@ -11,5 +11,4 @@ struct TestDisk {
     SCSIDevice parent_obj;
 };
 
-#endif //HW_SCSI_TEST_DISK_H
-./
\ No newline at end of file
+#endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
-- 
2.52.0


From 30039cdfd25a3706d3736a6fba1630c9125143e0 Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Tue, 20 Jan 2026 20:24:58 +0300
Subject: [PATCH 3/5] [ADD] Add socket connection with server

---
 hw/scsi/test_disk.c         | 72 +++++++++++++++++++++++++------------
 include/hw/scsi/test_disk.h |  2 ++
 2 files changed, 52 insertions(+), 22 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index 42a4f220f1..01481301fa 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -1,10 +1,9 @@
 #include "qemu/osdep.h"
 #include "hw/scsi/test_disk.h"
 #include "hw/scsi/scsi.h"
-#include "qapi/error.h"
 #include "scsi/constants.h"
 
-static int test_disk_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf, size_t buf_len, void *hba_private) {
+static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf, size_t buf_len, void* hba_private) {
     printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
 
     return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
@@ -16,10 +15,16 @@ typedef struct TestDiskReq {
 } TestDiskReq;
 
 static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
-    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, req->dev);
+
     uint8_t command = buf[0];
     uint8_t* outbuf = r->buf;
 
+    if (disk->socket) {
+        qio_channel_write_all(QIO_CHANNEL(disk->socket), (char*)&command, 1, NULL);
+    }
+
     switch (command) {
         case 0x00:
             printf("\tTEST_DISK: TEST UNIT READY\n");
@@ -30,12 +35,12 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
         case 0x12:
             printf("\tTEST_DISK: INQUIRY\n");
             memset(outbuf, 0, 36);
-            outbuf[0] = 0;   // Direct-access block device
-            outbuf[1] = 0;   // non-removable
-            outbuf[2] = 5;   // SPC-3
-            outbuf[3] = 2;   // response data format
-            outbuf[4] = 31;  // additional length
-            memcpy(&outbuf[8],  "QEMU    ", 8);
+            outbuf[0] = 0; // Direct-access block device
+            outbuf[1] = 0; // non-removable
+            outbuf[2] = 5; // SPC-3
+            outbuf[3] = 2; // response data format
+            outbuf[4] = 31; // additional length
+            memcpy(&outbuf[8], "QEMU    ", 8);
             memcpy(&outbuf[16], "TEST_DISK       ", 16);
 
             scsi_req_data(req, 36);
@@ -55,12 +60,12 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             outbuf[1] = (last_lba >> 16) & 0xff;
             outbuf[2] = (last_lba >> 8) & 0xff;
             outbuf[3] = last_lba & 0xff;
-            
+
             outbuf[4] = (block_size >> 24) & 0xff;
             outbuf[5] = (block_size >> 16) & 0xff;
             outbuf[6] = (block_size >> 8) & 0xff;
             outbuf[7] = block_size & 0xff;
-            
+
             scsi_req_data(req, 8);
 
             break;
@@ -69,8 +74,8 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             printf("\tTEST_DISK: MODE SENSE (6)\n");
 
             memset(outbuf, 0, 4);
-            outbuf[0] = 3;     // length
-            outbuf[2] = 0x80;  // write protection
+            outbuf[0] = 3; // length
+            outbuf[2] = 0x80; // write protection
 
             scsi_req_data(req, 4);
             break;
@@ -87,13 +92,12 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
     return 0;
 }
 
-static void test_disk_read_data(SCSIRequest *req) {
+static void test_disk_read_data(SCSIRequest* req) {
     scsi_req_complete(req, GOOD);
 }
 
-static uint8_t* test_disk_get_buf(SCSIRequest *req)
-{
-    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+static uint8_t* test_disk_get_buf(SCSIRequest* req) {
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
     return r->buf;
 }
 
@@ -104,17 +108,41 @@ static const SCSIReqOps test_disk_req_ops = {
     .get_buf = test_disk_get_buf
 };
 
-static SCSIRequest* test_disk_alloc_req(SCSIDevice *s, uint32_t tag, uint32_t lun, uint8_t *buf, void *hba_private) {
+static SCSIRequest* test_disk_alloc_req(SCSIDevice* s, uint32_t tag, uint32_t lun, uint8_t* buf, void* hba_private) {
     return scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
 }
 
-static void test_disk_realize(SCSIDevice *dev, Error **errp) {
+static void test_disk_realize(SCSIDevice* dev, Error** errp) {
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, dev);
+
+    SocketAddress addr = {
+        .type = SOCKET_ADDRESS_TYPE_INET,
+        .u.inet = {
+            .host = g_strdup("127.0.0.1"),
+            .port = g_strdup("31234")
+        }
+    };
+
+    disk->socket = qio_channel_socket_new();
+
+    if (qio_channel_socket_connect_sync(disk->socket, &addr, NULL) < 0) {
+        printf("SOCKET: failed to connect\n");
+
+        object_unref(OBJECT(disk->socket));
+        disk->socket = NULL;
+    } else {
+        printf("SOCKET: connected\n");
+    }
+
+    g_free(addr.u.inet.host);
+    g_free(addr.u.inet.port);
+
     printf("TEST_DISK: realized\n");
 }
 
-static void test_disk_class_init(ObjectClass *klass, const void *data) {
-    DeviceClass *dc = DEVICE_CLASS(klass);
-    SCSIDeviceClass *sc = SCSI_DEVICE_CLASS(klass);
+static void test_disk_class_init(ObjectClass* klass, const void* data) {
+    DeviceClass* dc = DEVICE_CLASS(klass);
+    SCSIDeviceClass* sc = SCSI_DEVICE_CLASS(klass);
 
     sc->realize = test_disk_realize;
     sc->parse_cdb = test_disk_parse_cdb;
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
index ac9e278372..c6a07db5dd 100644
--- a/include/hw/scsi/test_disk.h
+++ b/include/hw/scsi/test_disk.h
@@ -2,6 +2,7 @@
 #define HW_SCSI_TEST_DISK_H
 
 #include "hw/scsi/scsi.h"
+#include "io/channel-socket.h"
 #include "qom/object.h"
 
 #define TYPE_TEST_DISK "test_disk"
@@ -9,6 +10,7 @@ OBJECT_DECLARE_SIMPLE_TYPE(TestDisk, TEST_DISK)
 
 struct TestDisk {
     SCSIDevice parent_obj;
+    QIOChannelSocket* socket;
 };
 
 #endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
-- 
2.52.0


From bdcc99c3fef44623ab515b5fc3db93758ff61c22 Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Wed, 21 Jan 2026 20:00:40 +0300
Subject: [PATCH 4/5] [ADD] Add read command handler with delay

---
 hw/scsi/test_disk.c | 69 ++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 65 insertions(+), 4 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index 01481301fa..a4bf98bf5f 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -3,6 +3,9 @@
 #include "hw/scsi/scsi.h"
 #include "scsi/constants.h"
 
+// block size * max blocks
+#define MAX_READ_XFER_SIZE (512 * 2048) // 1MB
+
 static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf, size_t buf_len, void* hba_private) {
     printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
 
@@ -11,9 +14,25 @@ static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf,
 
 typedef struct TestDiskReq {
     SCSIRequest req;
-    uint8_t buf[256];
+    QEMUTimer* timer;
+    int len;
+    uint8_t buf[MAX_READ_XFER_SIZE];
 } TestDiskReq;
 
+static void test_disk_read_callback(void* opaque) {
+    printf("CALLBACK: from READ command\n");
+
+    TestDiskReq* r = opaque;
+
+    uint8_t* outbuf = r->buf;
+    memset(outbuf, 0, r->len);
+
+    scsi_req_data(&r->req, r->len);
+
+    timer_free(r->timer);
+    r->timer = NULL;
+}
+
 static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
     TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
     TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, req->dev);
@@ -52,7 +71,7 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             memset(outbuf, 0, 8);
 
             const uint32_t block_size = 512;
-            const uint32_t total_blocks = 2097152U;
+            const uint32_t total_blocks = 2048U;
 
             uint32_t last_lba = total_blocks - 1;
 
@@ -67,7 +86,6 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             outbuf[7] = block_size & 0xff;
 
             scsi_req_data(req, 8);
-
             break;
 
         case 0x1A:
@@ -80,12 +98,52 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             scsi_req_data(req, 4);
             break;
 
+        case 0x5A:
+            printf("\tTEST_DISK: MODE SENSE (10)\n");
+            memset(outbuf, 0, 8);
+
+            outbuf[0] = 0;
+            outbuf[1] = 6;
+
+            outbuf[3] = 0x80;
+
+            scsi_req_data(req, 8);
+            break;
+
+        case 0x08:
+        case 0x28:
+            int read_type = command == 0x08 ? 6 : 10;
+            printf("\tTEST_DISK: READ (%d)\n", read_type);
+
+            int target_len = (int)req->cmd.xfer;
+            printf("\tTARGET_LEN: %d\n", target_len);
+
+            if (target_len == 0) {
+                scsi_req_complete(req, GOOD);
+                break;
+            }
+
+            if (target_len > sizeof(r->buf)) {
+                printf("\tTEST_DISK: error - request too big\n");
+
+                scsi_req_build_sense(req, SENSE_CODE(LBA_OUT_OF_RANGE));
+                scsi_req_complete(req, CHECK_CONDITION);
+                break;
+            }
+
+            r->len = target_len;
+            r->timer = timer_new_ms(QEMU_CLOCK_REALTIME, test_disk_read_callback, r);
+
+            uint8_t delay_ms = 0;
+            timer_mod(r->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + delay_ms);
+
+            return 0;
+
         default:
             printf("\tTEST_DISK: rejecting command 0x%02x\n", command);
 
             scsi_req_build_sense(req, SENSE_CODE(INVALID_OPCODE));
             scsi_req_complete(req, CHECK_CONDITION);
-
             break;
     }
 
@@ -113,6 +171,9 @@ static SCSIRequest* test_disk_alloc_req(SCSIDevice* s, uint32_t tag, uint32_t lu
 }
 
 static void test_disk_realize(SCSIDevice* dev, Error** errp) {
+    dev->type = TYPE_DISK;
+    dev->blocksize = 512;
+
     TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, dev);
 
     SocketAddress addr = {
-- 
2.52.0


From c85a868d1b83d6ff5c7b495741d9e593adcf943f Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Thu, 22 Jan 2026 18:37:00 +0300
Subject: [PATCH 5/5] [ADD] Add ability to set constants

---
 hw/scsi/test_disk.c         | 47 +++++++++++++++++++++++++++++--------
 include/hw/scsi/test_disk.h |  5 ++++
 2 files changed, 42 insertions(+), 10 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index a4bf98bf5f..0669c92192 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -16,9 +16,16 @@ typedef struct TestDiskReq {
     SCSIRequest req;
     QEMUTimer* timer;
     int len;
-    uint8_t buf[MAX_READ_XFER_SIZE];
+
+    uint8_t* buf;
 } TestDiskReq;
 
+static Property test_disk_properties[] = {
+    DEFINE_PROP_SIZE("size", TestDisk, size, 1 * 1024 * 1024 * 1024),
+    DEFINE_PROP_SIZE("bs", TestDisk, block_size, 512),
+    DEFINE_PROP_SIZE("max_xfer_size", TestDisk, max_xfer_size, 1 * 1024 * 1024),
+};
+
 static void test_disk_read_callback(void* opaque) {
     printf("CALLBACK: from READ command\n");
 
@@ -70,8 +77,8 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
 
             memset(outbuf, 0, 8);
 
-            const uint32_t block_size = 512;
-            const uint32_t total_blocks = 2048U;
+            const uint32_t block_size = disk->block_size;
+            const uint32_t total_blocks = disk->size / disk->block_size;
 
             uint32_t last_lba = total_blocks - 1;
 
@@ -123,10 +130,10 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
                 break;
             }
 
-            if (target_len > sizeof(r->buf)) {
+            if (target_len > disk->max_xfer_size) {
                 printf("\tTEST_DISK: error - request too big\n");
 
-                scsi_req_build_sense(req, SENSE_CODE(LBA_OUT_OF_RANGE));
+                scsi_req_build_sense(req, SENSE_CODE(INVALID_FIELD));
                 scsi_req_complete(req, CHECK_CONDITION);
                 break;
             }
@@ -159,23 +166,41 @@ static uint8_t* test_disk_get_buf(SCSIRequest* req) {
     return r->buf;
 }
 
+static void test_disk_free_req(SCSIRequest* req) {
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
+
+    if (r->buf) {
+        g_free(r->buf);
+        r->buf = NULL;
+    }
+}
+
 static const SCSIReqOps test_disk_req_ops = {
     .size = sizeof(TestDiskReq),
     .send_command = test_disk_send_command,
     .read_data = test_disk_read_data,
-    .get_buf = test_disk_get_buf
+    .get_buf = test_disk_get_buf,
+    .free_req = test_disk_free_req
 };
 
 static SCSIRequest* test_disk_alloc_req(SCSIDevice* s, uint32_t tag, uint32_t lun, uint8_t* buf, void* hba_private) {
-    return scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, s);
+    uint64_t max_xfer_size = disk->max_xfer_size;
+
+    SCSIRequest* req = scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
+
+    r->buf = g_malloc0(max_xfer_size);
+
+    return req;
 }
 
 static void test_disk_realize(SCSIDevice* dev, Error** errp) {
-    dev->type = TYPE_DISK;
-    dev->blocksize = 512;
-
     TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, dev);
 
+    dev->type = TYPE_DISK;
+    dev->blocksize = (int)disk->block_size;
+
     SocketAddress addr = {
         .type = SOCKET_ADDRESS_TYPE_INET,
         .u.inet = {
@@ -211,6 +236,8 @@ static void test_disk_class_init(ObjectClass* klass, const void* data) {
 
     set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
     dc->desc = "Test SCSI Disk";
+
+    device_class_set_props(dc, test_disk_properties);
 }
 
 static const TypeInfo test_disk_info = {
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
index c6a07db5dd..a86908d965 100644
--- a/include/hw/scsi/test_disk.h
+++ b/include/hw/scsi/test_disk.h
@@ -11,6 +11,11 @@ OBJECT_DECLARE_SIMPLE_TYPE(TestDisk, TEST_DISK)
 struct TestDisk {
     SCSIDevice parent_obj;
     QIOChannelSocket* socket;
+
+    uint64_t size;
+    uint64_t block_size;
+
+    uint64_t max_xfer_size;
 };
 
 #endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
-- 
2.52.0

From 262ff0d0d6db6e6404265a494215fd3785bb999e Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Tue, 13 Jan 2026 19:53:51 +0300
Subject: [PATCH 1/6] [ADD] Add test scsi disk

---
 .gitignore                  |  1 +
 hw/scsi/Kconfig             |  5 +++++
 hw/scsi/meson.build         |  1 +
 hw/scsi/test_disk.c         | 38 +++++++++++++++++++++++++++++++++++++
 include/hw/scsi/test_disk.h | 15 +++++++++++++++
 5 files changed, 60 insertions(+)
 create mode 100644 hw/scsi/test_disk.c
 create mode 100644 include/hw/scsi/test_disk.h

diff --git a/.gitignore b/.gitignore
index 61fa39967b..a0687c79d5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,6 +2,7 @@
 /build/
 /.cache/
 /.vscode/
+/.idea/
 *.pyc
 .sdk
 .stgit-*
diff --git a/hw/scsi/Kconfig b/hw/scsi/Kconfig
index 5743ee9b4d..fcc81b304a 100644
--- a/hw/scsi/Kconfig
+++ b/hw/scsi/Kconfig
@@ -69,3 +69,8 @@ config VHOST_USER_SCSI
     default y if VIRTIO_PCI
     select VHOST_SCSI_COMMON
     depends on VIRTIO && VHOST_USER && LINUX
+
+config TEST_DISK
+    bool
+    default y
+    depends on SCSI
diff --git a/hw/scsi/meson.build b/hw/scsi/meson.build
index b874fe1ecd..a45671e646 100644
--- a/hw/scsi/meson.build
+++ b/hw/scsi/meson.build
@@ -16,6 +16,7 @@ scsi_ss.add(when: 'CONFIG_NCR710_SCSI', if_true: files('ncr53c710.c', 'lasi_ncr7
 scsi_ss.add(when: 'CONFIG_MEGASAS_SCSI_PCI', if_true: files('megasas.c'))
 scsi_ss.add(when: 'CONFIG_MPTSAS_SCSI_PCI', if_true: files('mptsas.c', 'mptconfig.c', 'mptendian.c'))
 scsi_ss.add(when: 'CONFIG_VMW_PVSCSI_SCSI_PCI', if_true: files('vmw_pvscsi.c'))
+scsi_ss.add(when: 'CONFIG_TEST_DISK', if_true: files('test_disk.c'))
 
 virtio_scsi_ss.add(files('virtio-scsi-dataplane.c'))
 virtio_scsi_ss.add(when: 'CONFIG_VHOST_SCSI', if_true: files('vhost-scsi.c'))
diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
new file mode 100644
index 0000000000..a8c774182b
--- /dev/null
+++ b/hw/scsi/test_disk.c
@@ -0,0 +1,38 @@
+#include "qemu/osdep.h"
+#include "hw/scsi/test_disk.h"
+#include "hw/scsi/scsi.h"
+#include "qapi/error.h"
+
+static int test_disk_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf, size_t buf_len, void *hba_private) {
+    printf("MySCSIDevice: Received CDB command 0x%02x\n", buf[0]);
+
+    return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
+}
+
+static void test_disk_realize(SCSIDevice *dev, Error **errp) {
+    printf("MySCSIDevice: Device realized (initialized)\n");
+}
+
+static void test_disk_class_init(ObjectClass *klass, const void *data) {
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    SCSIDeviceClass *sc = SCSI_DEVICE_CLASS(klass);
+
+    sc->realize = test_disk_realize;
+    sc->parse_cdb = test_disk_parse_cdb;
+
+    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
+    dc->desc = "Test SCSI Disk";
+}
+
+static const TypeInfo test_disk_info = {
+    .name = TYPE_TEST_DISK,
+    .parent = TYPE_SCSI_DEVICE,
+    .instance_size = sizeof(TestDisk),
+    .class_init = test_disk_class_init,
+};
+
+static void test_disk_register_types(void) {
+    type_register_static(&test_disk_info);
+}
+
+type_init(test_disk_register_types)
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
new file mode 100644
index 0000000000..be2f7ccbd3
--- /dev/null
+++ b/include/hw/scsi/test_disk.h
@@ -0,0 +1,15 @@
+#ifndef HW_SCSI_TEST_DISK_H
+#define HW_SCSI_TEST_DISK_H
+
+#include "hw/scsi/scsi.h"
+#include "qom/object.h"
+
+#define TYPE_TEST_DISK "test_disk"
+OBJECT_DECLARE_SIMPLE_TYPE(TestDisk, TEST_DISK)
+
+struct TestDisk {
+    SCSIDevice parent_obj;
+};
+
+#endif //HW_SCSI_TEST_DISK_H
+./
\ No newline at end of file
-- 
2.52.0


From 6e84f169872c8bd39c363569a22094ad264de2a3 Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Thu, 15 Jan 2026 18:12:16 +0300
Subject: [PATCH 2/6] [ADD] Add basic request handling

---
 hw/scsi/test_disk.c         | 104 +++++++++++++++++++++++++++++++++++-
 include/hw/scsi/test_disk.h |   3 +-
 2 files changed, 103 insertions(+), 4 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index a8c774182b..42a4f220f1 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -2,15 +2,114 @@
 #include "hw/scsi/test_disk.h"
 #include "hw/scsi/scsi.h"
 #include "qapi/error.h"
+#include "scsi/constants.h"
 
 static int test_disk_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf, size_t buf_len, void *hba_private) {
-    printf("MySCSIDevice: Received CDB command 0x%02x\n", buf[0]);
+    printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
 
     return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
 }
 
+typedef struct TestDiskReq {
+    SCSIRequest req;
+    uint8_t buf[256];
+} TestDiskReq;
+
+static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
+    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+    uint8_t command = buf[0];
+    uint8_t* outbuf = r->buf;
+
+    switch (command) {
+        case 0x00:
+            printf("\tTEST_DISK: TEST UNIT READY\n");
+
+            scsi_req_complete(req, GOOD);
+            break;
+
+        case 0x12:
+            printf("\tTEST_DISK: INQUIRY\n");
+            memset(outbuf, 0, 36);
+            outbuf[0] = 0;   // Direct-access block device
+            outbuf[1] = 0;   // non-removable
+            outbuf[2] = 5;   // SPC-3
+            outbuf[3] = 2;   // response data format
+            outbuf[4] = 31;  // additional length
+            memcpy(&outbuf[8],  "QEMU    ", 8);
+            memcpy(&outbuf[16], "TEST_DISK       ", 16);
+
+            scsi_req_data(req, 36);
+            break;
+
+        case 0x25:
+            printf("\tTEST_DISK: READ CAPACITY (10)\n");
+
+            memset(outbuf, 0, 8);
+
+            const uint32_t block_size = 512;
+            const uint32_t total_blocks = 2097152U;
+
+            uint32_t last_lba = total_blocks - 1;
+
+            outbuf[0] = (last_lba >> 24) & 0xff;
+            outbuf[1] = (last_lba >> 16) & 0xff;
+            outbuf[2] = (last_lba >> 8) & 0xff;
+            outbuf[3] = last_lba & 0xff;
+            
+            outbuf[4] = (block_size >> 24) & 0xff;
+            outbuf[5] = (block_size >> 16) & 0xff;
+            outbuf[6] = (block_size >> 8) & 0xff;
+            outbuf[7] = block_size & 0xff;
+            
+            scsi_req_data(req, 8);
+
+            break;
+
+        case 0x1A:
+            printf("\tTEST_DISK: MODE SENSE (6)\n");
+
+            memset(outbuf, 0, 4);
+            outbuf[0] = 3;     // length
+            outbuf[2] = 0x80;  // write protection
+
+            scsi_req_data(req, 4);
+            break;
+
+        default:
+            printf("\tTEST_DISK: rejecting command 0x%02x\n", command);
+
+            scsi_req_build_sense(req, SENSE_CODE(INVALID_OPCODE));
+            scsi_req_complete(req, CHECK_CONDITION);
+
+            break;
+    }
+
+    return 0;
+}
+
+static void test_disk_read_data(SCSIRequest *req) {
+    scsi_req_complete(req, GOOD);
+}
+
+static uint8_t* test_disk_get_buf(SCSIRequest *req)
+{
+    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+    return r->buf;
+}
+
+static const SCSIReqOps test_disk_req_ops = {
+    .size = sizeof(TestDiskReq),
+    .send_command = test_disk_send_command,
+    .read_data = test_disk_read_data,
+    .get_buf = test_disk_get_buf
+};
+
+static SCSIRequest* test_disk_alloc_req(SCSIDevice *s, uint32_t tag, uint32_t lun, uint8_t *buf, void *hba_private) {
+    return scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
+}
+
 static void test_disk_realize(SCSIDevice *dev, Error **errp) {
-    printf("MySCSIDevice: Device realized (initialized)\n");
+    printf("TEST_DISK: realized\n");
 }
 
 static void test_disk_class_init(ObjectClass *klass, const void *data) {
@@ -19,6 +118,7 @@ static void test_disk_class_init(ObjectClass *klass, const void *data) {
 
     sc->realize = test_disk_realize;
     sc->parse_cdb = test_disk_parse_cdb;
+    sc->alloc_req = test_disk_alloc_req;
 
     set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
     dc->desc = "Test SCSI Disk";
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
index be2f7ccbd3..ac9e278372 100644
--- a/include/hw/scsi/test_disk.h
+++ b/include/hw/scsi/test_disk.h
@@ -11,5 +11,4 @@ struct TestDisk {
     SCSIDevice parent_obj;
 };
 
-#endif //HW_SCSI_TEST_DISK_H
-./
\ No newline at end of file
+#endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
-- 
2.52.0


From 30039cdfd25a3706d3736a6fba1630c9125143e0 Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Tue, 20 Jan 2026 20:24:58 +0300
Subject: [PATCH 3/6] [ADD] Add socket connection with server

---
 hw/scsi/test_disk.c         | 72 +++++++++++++++++++++++++------------
 include/hw/scsi/test_disk.h |  2 ++
 2 files changed, 52 insertions(+), 22 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index 42a4f220f1..01481301fa 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -1,10 +1,9 @@
 #include "qemu/osdep.h"
 #include "hw/scsi/test_disk.h"
 #include "hw/scsi/scsi.h"
-#include "qapi/error.h"
 #include "scsi/constants.h"
 
-static int test_disk_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf, size_t buf_len, void *hba_private) {
+static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf, size_t buf_len, void* hba_private) {
     printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
 
     return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
@@ -16,10 +15,16 @@ typedef struct TestDiskReq {
 } TestDiskReq;
 
 static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
-    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, req->dev);
+
     uint8_t command = buf[0];
     uint8_t* outbuf = r->buf;
 
+    if (disk->socket) {
+        qio_channel_write_all(QIO_CHANNEL(disk->socket), (char*)&command, 1, NULL);
+    }
+
     switch (command) {
         case 0x00:
             printf("\tTEST_DISK: TEST UNIT READY\n");
@@ -30,12 +35,12 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
         case 0x12:
             printf("\tTEST_DISK: INQUIRY\n");
             memset(outbuf, 0, 36);
-            outbuf[0] = 0;   // Direct-access block device
-            outbuf[1] = 0;   // non-removable
-            outbuf[2] = 5;   // SPC-3
-            outbuf[3] = 2;   // response data format
-            outbuf[4] = 31;  // additional length
-            memcpy(&outbuf[8],  "QEMU    ", 8);
+            outbuf[0] = 0; // Direct-access block device
+            outbuf[1] = 0; // non-removable
+            outbuf[2] = 5; // SPC-3
+            outbuf[3] = 2; // response data format
+            outbuf[4] = 31; // additional length
+            memcpy(&outbuf[8], "QEMU    ", 8);
             memcpy(&outbuf[16], "TEST_DISK       ", 16);
 
             scsi_req_data(req, 36);
@@ -55,12 +60,12 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             outbuf[1] = (last_lba >> 16) & 0xff;
             outbuf[2] = (last_lba >> 8) & 0xff;
             outbuf[3] = last_lba & 0xff;
-            
+
             outbuf[4] = (block_size >> 24) & 0xff;
             outbuf[5] = (block_size >> 16) & 0xff;
             outbuf[6] = (block_size >> 8) & 0xff;
             outbuf[7] = block_size & 0xff;
-            
+
             scsi_req_data(req, 8);
 
             break;
@@ -69,8 +74,8 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             printf("\tTEST_DISK: MODE SENSE (6)\n");
 
             memset(outbuf, 0, 4);
-            outbuf[0] = 3;     // length
-            outbuf[2] = 0x80;  // write protection
+            outbuf[0] = 3; // length
+            outbuf[2] = 0x80; // write protection
 
             scsi_req_data(req, 4);
             break;
@@ -87,13 +92,12 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
     return 0;
 }
 
-static void test_disk_read_data(SCSIRequest *req) {
+static void test_disk_read_data(SCSIRequest* req) {
     scsi_req_complete(req, GOOD);
 }
 
-static uint8_t* test_disk_get_buf(SCSIRequest *req)
-{
-    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+static uint8_t* test_disk_get_buf(SCSIRequest* req) {
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
     return r->buf;
 }
 
@@ -104,17 +108,41 @@ static const SCSIReqOps test_disk_req_ops = {
     .get_buf = test_disk_get_buf
 };
 
-static SCSIRequest* test_disk_alloc_req(SCSIDevice *s, uint32_t tag, uint32_t lun, uint8_t *buf, void *hba_private) {
+static SCSIRequest* test_disk_alloc_req(SCSIDevice* s, uint32_t tag, uint32_t lun, uint8_t* buf, void* hba_private) {
     return scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
 }
 
-static void test_disk_realize(SCSIDevice *dev, Error **errp) {
+static void test_disk_realize(SCSIDevice* dev, Error** errp) {
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, dev);
+
+    SocketAddress addr = {
+        .type = SOCKET_ADDRESS_TYPE_INET,
+        .u.inet = {
+            .host = g_strdup("127.0.0.1"),
+            .port = g_strdup("31234")
+        }
+    };
+
+    disk->socket = qio_channel_socket_new();
+
+    if (qio_channel_socket_connect_sync(disk->socket, &addr, NULL) < 0) {
+        printf("SOCKET: failed to connect\n");
+
+        object_unref(OBJECT(disk->socket));
+        disk->socket = NULL;
+    } else {
+        printf("SOCKET: connected\n");
+    }
+
+    g_free(addr.u.inet.host);
+    g_free(addr.u.inet.port);
+
     printf("TEST_DISK: realized\n");
 }
 
-static void test_disk_class_init(ObjectClass *klass, const void *data) {
-    DeviceClass *dc = DEVICE_CLASS(klass);
-    SCSIDeviceClass *sc = SCSI_DEVICE_CLASS(klass);
+static void test_disk_class_init(ObjectClass* klass, const void* data) {
+    DeviceClass* dc = DEVICE_CLASS(klass);
+    SCSIDeviceClass* sc = SCSI_DEVICE_CLASS(klass);
 
     sc->realize = test_disk_realize;
     sc->parse_cdb = test_disk_parse_cdb;
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
index ac9e278372..c6a07db5dd 100644
--- a/include/hw/scsi/test_disk.h
+++ b/include/hw/scsi/test_disk.h
@@ -2,6 +2,7 @@
 #define HW_SCSI_TEST_DISK_H
 
 #include "hw/scsi/scsi.h"
+#include "io/channel-socket.h"
 #include "qom/object.h"
 
 #define TYPE_TEST_DISK "test_disk"
@@ -9,6 +10,7 @@ OBJECT_DECLARE_SIMPLE_TYPE(TestDisk, TEST_DISK)
 
 struct TestDisk {
     SCSIDevice parent_obj;
+    QIOChannelSocket* socket;
 };
 
 #endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
-- 
2.52.0


From bdcc99c3fef44623ab515b5fc3db93758ff61c22 Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Wed, 21 Jan 2026 20:00:40 +0300
Subject: [PATCH 4/6] [ADD] Add read command handler with delay

---
 hw/scsi/test_disk.c | 69 ++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 65 insertions(+), 4 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index 01481301fa..a4bf98bf5f 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -3,6 +3,9 @@
 #include "hw/scsi/scsi.h"
 #include "scsi/constants.h"
 
+// block size * max blocks
+#define MAX_READ_XFER_SIZE (512 * 2048) // 1MB
+
 static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf, size_t buf_len, void* hba_private) {
     printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
 
@@ -11,9 +14,25 @@ static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf,
 
 typedef struct TestDiskReq {
     SCSIRequest req;
-    uint8_t buf[256];
+    QEMUTimer* timer;
+    int len;
+    uint8_t buf[MAX_READ_XFER_SIZE];
 } TestDiskReq;
 
+static void test_disk_read_callback(void* opaque) {
+    printf("CALLBACK: from READ command\n");
+
+    TestDiskReq* r = opaque;
+
+    uint8_t* outbuf = r->buf;
+    memset(outbuf, 0, r->len);
+
+    scsi_req_data(&r->req, r->len);
+
+    timer_free(r->timer);
+    r->timer = NULL;
+}
+
 static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
     TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
     TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, req->dev);
@@ -52,7 +71,7 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             memset(outbuf, 0, 8);
 
             const uint32_t block_size = 512;
-            const uint32_t total_blocks = 2097152U;
+            const uint32_t total_blocks = 2048U;
 
             uint32_t last_lba = total_blocks - 1;
 
@@ -67,7 +86,6 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             outbuf[7] = block_size & 0xff;
 
             scsi_req_data(req, 8);
-
             break;
 
         case 0x1A:
@@ -80,12 +98,52 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             scsi_req_data(req, 4);
             break;
 
+        case 0x5A:
+            printf("\tTEST_DISK: MODE SENSE (10)\n");
+            memset(outbuf, 0, 8);
+
+            outbuf[0] = 0;
+            outbuf[1] = 6;
+
+            outbuf[3] = 0x80;
+
+            scsi_req_data(req, 8);
+            break;
+
+        case 0x08:
+        case 0x28:
+            int read_type = command == 0x08 ? 6 : 10;
+            printf("\tTEST_DISK: READ (%d)\n", read_type);
+
+            int target_len = (int)req->cmd.xfer;
+            printf("\tTARGET_LEN: %d\n", target_len);
+
+            if (target_len == 0) {
+                scsi_req_complete(req, GOOD);
+                break;
+            }
+
+            if (target_len > sizeof(r->buf)) {
+                printf("\tTEST_DISK: error - request too big\n");
+
+                scsi_req_build_sense(req, SENSE_CODE(LBA_OUT_OF_RANGE));
+                scsi_req_complete(req, CHECK_CONDITION);
+                break;
+            }
+
+            r->len = target_len;
+            r->timer = timer_new_ms(QEMU_CLOCK_REALTIME, test_disk_read_callback, r);
+
+            uint8_t delay_ms = 0;
+            timer_mod(r->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + delay_ms);
+
+            return 0;
+
         default:
             printf("\tTEST_DISK: rejecting command 0x%02x\n", command);
 
             scsi_req_build_sense(req, SENSE_CODE(INVALID_OPCODE));
             scsi_req_complete(req, CHECK_CONDITION);
-
             break;
     }
 
@@ -113,6 +171,9 @@ static SCSIRequest* test_disk_alloc_req(SCSIDevice* s, uint32_t tag, uint32_t lu
 }
 
 static void test_disk_realize(SCSIDevice* dev, Error** errp) {
+    dev->type = TYPE_DISK;
+    dev->blocksize = 512;
+
     TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, dev);
 
     SocketAddress addr = {
-- 
2.52.0


From c85a868d1b83d6ff5c7b495741d9e593adcf943f Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Thu, 22 Jan 2026 18:37:00 +0300
Subject: [PATCH 5/6] [ADD] Add ability to set constants

---
 hw/scsi/test_disk.c         | 47 +++++++++++++++++++++++++++++--------
 include/hw/scsi/test_disk.h |  5 ++++
 2 files changed, 42 insertions(+), 10 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index a4bf98bf5f..0669c92192 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -16,9 +16,16 @@ typedef struct TestDiskReq {
     SCSIRequest req;
     QEMUTimer* timer;
     int len;
-    uint8_t buf[MAX_READ_XFER_SIZE];
+
+    uint8_t* buf;
 } TestDiskReq;
 
+static Property test_disk_properties[] = {
+    DEFINE_PROP_SIZE("size", TestDisk, size, 1 * 1024 * 1024 * 1024),
+    DEFINE_PROP_SIZE("bs", TestDisk, block_size, 512),
+    DEFINE_PROP_SIZE("max_xfer_size", TestDisk, max_xfer_size, 1 * 1024 * 1024),
+};
+
 static void test_disk_read_callback(void* opaque) {
     printf("CALLBACK: from READ command\n");
 
@@ -70,8 +77,8 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
 
             memset(outbuf, 0, 8);
 
-            const uint32_t block_size = 512;
-            const uint32_t total_blocks = 2048U;
+            const uint32_t block_size = disk->block_size;
+            const uint32_t total_blocks = disk->size / disk->block_size;
 
             uint32_t last_lba = total_blocks - 1;
 
@@ -123,10 +130,10 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
                 break;
             }
 
-            if (target_len > sizeof(r->buf)) {
+            if (target_len > disk->max_xfer_size) {
                 printf("\tTEST_DISK: error - request too big\n");
 
-                scsi_req_build_sense(req, SENSE_CODE(LBA_OUT_OF_RANGE));
+                scsi_req_build_sense(req, SENSE_CODE(INVALID_FIELD));
                 scsi_req_complete(req, CHECK_CONDITION);
                 break;
             }
@@ -159,23 +166,41 @@ static uint8_t* test_disk_get_buf(SCSIRequest* req) {
     return r->buf;
 }
 
+static void test_disk_free_req(SCSIRequest* req) {
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
+
+    if (r->buf) {
+        g_free(r->buf);
+        r->buf = NULL;
+    }
+}
+
 static const SCSIReqOps test_disk_req_ops = {
     .size = sizeof(TestDiskReq),
     .send_command = test_disk_send_command,
     .read_data = test_disk_read_data,
-    .get_buf = test_disk_get_buf
+    .get_buf = test_disk_get_buf,
+    .free_req = test_disk_free_req
 };
 
 static SCSIRequest* test_disk_alloc_req(SCSIDevice* s, uint32_t tag, uint32_t lun, uint8_t* buf, void* hba_private) {
-    return scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, s);
+    uint64_t max_xfer_size = disk->max_xfer_size;
+
+    SCSIRequest* req = scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
+
+    r->buf = g_malloc0(max_xfer_size);
+
+    return req;
 }
 
 static void test_disk_realize(SCSIDevice* dev, Error** errp) {
-    dev->type = TYPE_DISK;
-    dev->blocksize = 512;
-
     TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, dev);
 
+    dev->type = TYPE_DISK;
+    dev->blocksize = (int)disk->block_size;
+
     SocketAddress addr = {
         .type = SOCKET_ADDRESS_TYPE_INET,
         .u.inet = {
@@ -211,6 +236,8 @@ static void test_disk_class_init(ObjectClass* klass, const void* data) {
 
     set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
     dc->desc = "Test SCSI Disk";
+
+    device_class_set_props(dc, test_disk_properties);
 }
 
 static const TypeInfo test_disk_info = {
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
index c6a07db5dd..a86908d965 100644
--- a/include/hw/scsi/test_disk.h
+++ b/include/hw/scsi/test_disk.h
@@ -11,6 +11,11 @@ OBJECT_DECLARE_SIMPLE_TYPE(TestDisk, TEST_DISK)
 struct TestDisk {
     SCSIDevice parent_obj;
     QIOChannelSocket* socket;
+
+    uint64_t size;
+    uint64_t block_size;
+
+    uint64_t max_xfer_size;
 };
 
 #endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
-- 
2.52.0


From 46d1e5f6345471f28022a7df98aee204340c8053 Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Fri, 23 Jan 2026 01:28:47 +0300
Subject: [PATCH 6/6] [REF] Reafactor + async socket connection and
 reconnection mechanism

---
 hw/scsi/test_disk.c                 | 348 +++++++++++++++++-----------
 {include/hw => hw}/scsi/test_disk.h |   8 +-
 2 files changed, 216 insertions(+), 140 deletions(-)
 rename {include/hw => hw}/scsi/test_disk.h (74%)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index 0669c92192..f0262586a9 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -1,205 +1,199 @@
 #include "qemu/osdep.h"
-#include "hw/scsi/test_disk.h"
 #include "hw/scsi/scsi.h"
+#include "test_disk.h"
+#include "qapi/error.h"
 #include "scsi/constants.h"
 
-// block size * max blocks
-#define MAX_READ_XFER_SIZE (512 * 2048) // 1MB
 
-static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf, size_t buf_len, void* hba_private) {
-    printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
+// Device properties
+static const Property test_disk_properties[] = {
+    DEFINE_PROP_SIZE("size", TestDisk, size, 1 * 1024 * 1024 * 1024),
+    DEFINE_PROP_SIZE("bs", TestDisk, block_size, 512),
+    DEFINE_PROP_SIZE("max_xfer_size", TestDisk, max_xfer_size, 1 * 1024 * 1024),
+};
 
-    return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
-}
 
+// Request
 typedef struct TestDiskReq {
-    SCSIRequest req;
+    SCSIRequest parent_scsi_req;
     QEMUTimer* timer;
-    int len;
 
-    uint8_t* buf;
+    uint8_t* response_buf;
+    int response_buf_len;
 } TestDiskReq;
 
-static Property test_disk_properties[] = {
-    DEFINE_PROP_SIZE("size", TestDisk, size, 1 * 1024 * 1024 * 1024),
-    DEFINE_PROP_SIZE("bs", TestDisk, block_size, 512),
-    DEFINE_PROP_SIZE("max_xfer_size", TestDisk, max_xfer_size, 1 * 1024 * 1024),
+
+// Request handlers
+static int32_t test_disk_send_command(SCSIRequest* scsi_req, uint8_t* request_buf);
+static void test_disk_read_data(SCSIRequest* scsi_req);
+static uint8_t* test_disk_get_buf(SCSIRequest* scsi_req);
+static void test_disk_free_req(SCSIRequest* scsi_req);
+
+
+// Request handlers map
+static const SCSIReqOps test_disk_req_ops = {
+    .size = sizeof(TestDiskReq),
+    .send_command = test_disk_send_command,
+    .read_data = test_disk_read_data,
+    .get_buf = test_disk_get_buf,
+    .free_req = test_disk_free_req
 };
 
-static void test_disk_read_callback(void* opaque) {
-    printf("CALLBACK: from READ command\n");
 
-    TestDiskReq* r = opaque;
+// Helper functions
+static void test_disk_socket_start_connection(void* opaque);
+static void test_disk_socket_connected(QIOTask* task, gpointer opaque);
+static void test_disk_read_callback(void* opaque);
 
-    uint8_t* outbuf = r->buf;
-    memset(outbuf, 0, r->len);
 
-    scsi_req_data(&r->req, r->len);
+// ============================================================================
 
-    timer_free(r->timer);
-    r->timer = NULL;
-}
 
-static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
-    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
-    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, req->dev);
+static int32_t test_disk_send_command(SCSIRequest* scsi_req, uint8_t* request_buf) {
+    TestDiskReq* disk_req = DO_UPCAST(TestDiskReq, parent_scsi_req, scsi_req);
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_scsi_dev, scsi_req->dev);
 
-    uint8_t command = buf[0];
-    uint8_t* outbuf = r->buf;
+    uint8_t command = request_buf[0];
 
-    if (disk->socket) {
-        qio_channel_write_all(QIO_CHANNEL(disk->socket), (char*)&command, 1, NULL);
-    }
+    // INQUIRY request is handled even without socket
+    if (command == 0x12) { // INQUIRY
+        memset(disk_req->response_buf, 0, 36);
 
-    switch (command) {
-        case 0x00:
-            printf("\tTEST_DISK: TEST UNIT READY\n");
+        disk_req->response_buf[0] = 0; // Direct-access block device
+        disk_req->response_buf[1] = 0; // non-removable
+        disk_req->response_buf[2] = 5; // SPC-3
+        disk_req->response_buf[3] = 2; // response data format
+        disk_req->response_buf[4] = 31; // additional length
 
-            scsi_req_complete(req, GOOD);
-            break;
+        memcpy(&disk_req->response_buf[8], "QEMU", 4); // vendor
+        memcpy(&disk_req->response_buf[16], "TEST_DISK", 9); // product
 
-        case 0x12:
-            printf("\tTEST_DISK: INQUIRY\n");
-            memset(outbuf, 0, 36);
-            outbuf[0] = 0; // Direct-access block device
-            outbuf[1] = 0; // non-removable
-            outbuf[2] = 5; // SPC-3
-            outbuf[3] = 2; // response data format
-            outbuf[4] = 31; // additional length
-            memcpy(&outbuf[8], "QEMU    ", 8);
-            memcpy(&outbuf[16], "TEST_DISK       ", 16);
-
-            scsi_req_data(req, 36);
-            break;
+        scsi_req_data(scsi_req, 36);
+        return 0;
+    }
 
-        case 0x25:
-            printf("\tTEST_DISK: READ CAPACITY (10)\n");
+    if (!disk->socket) {
+        scsi_req_build_sense(scsi_req, SENSE_CODE(NOT_READY));
+        scsi_req_complete(scsi_req, CHECK_CONDITION);
+        return 0;
+    }
+
+    switch (command) {
+        case 0x00: // TEST UNIT READY
+            scsi_req_complete(scsi_req, GOOD);
+            break;
 
-            memset(outbuf, 0, 8);
+        case 0x25: // READ CAPACITY (10)
+            memset(disk_req->response_buf, 0, 8);
 
             const uint32_t block_size = disk->block_size;
             const uint32_t total_blocks = disk->size / disk->block_size;
 
-            uint32_t last_lba = total_blocks - 1;
+            const uint32_t last_lba = total_blocks - 1;
 
-            outbuf[0] = (last_lba >> 24) & 0xff;
-            outbuf[1] = (last_lba >> 16) & 0xff;
-            outbuf[2] = (last_lba >> 8) & 0xff;
-            outbuf[3] = last_lba & 0xff;
+            disk_req->response_buf[0] = (last_lba >> 24) & 0xff;
+            disk_req->response_buf[1] = (last_lba >> 16) & 0xff;
+            disk_req->response_buf[2] = (last_lba >> 8) & 0xff;
+            disk_req->response_buf[3] = last_lba & 0xff;
 
-            outbuf[4] = (block_size >> 24) & 0xff;
-            outbuf[5] = (block_size >> 16) & 0xff;
-            outbuf[6] = (block_size >> 8) & 0xff;
-            outbuf[7] = block_size & 0xff;
+            disk_req->response_buf[4] = (block_size >> 24) & 0xff;
+            disk_req->response_buf[5] = (block_size >> 16) & 0xff;
+            disk_req->response_buf[6] = (block_size >> 8) & 0xff;
+            disk_req->response_buf[7] = block_size & 0xff;
 
-            scsi_req_data(req, 8);
+            scsi_req_data(scsi_req, 8);
             break;
 
-        case 0x1A:
-            printf("\tTEST_DISK: MODE SENSE (6)\n");
+        case 0x1A: // MODE SENSE (6)
+            memset(disk_req->response_buf, 0, 4);
 
-            memset(outbuf, 0, 4);
-            outbuf[0] = 3; // length
-            outbuf[2] = 0x80; // write protection
+            disk_req->response_buf[0] = 3; // length
+            disk_req->response_buf[2] = 0x80; // write protection
 
-            scsi_req_data(req, 4);
+            scsi_req_data(scsi_req, 4);
             break;
 
-        case 0x5A:
-            printf("\tTEST_DISK: MODE SENSE (10)\n");
-            memset(outbuf, 0, 8);
-
-            outbuf[0] = 0;
-            outbuf[1] = 6;
+        case 0x5A: // MODE SENSE (10)
+            memset(disk_req->response_buf, 0, 8);
 
-            outbuf[3] = 0x80;
+            disk_req->response_buf[0] = 0;
+            disk_req->response_buf[1] = 6;
+            disk_req->response_buf[3] = 0x80;
 
-            scsi_req_data(req, 8);
+            scsi_req_data(scsi_req, 8);
             break;
 
-        case 0x08:
-        case 0x28:
-            int read_type = command == 0x08 ? 6 : 10;
-            printf("\tTEST_DISK: READ (%d)\n", read_type);
+        case 0x08: // READ (6)
+        case 0x28: // READ (10)
 
-            int target_len = (int)req->cmd.xfer;
-            printf("\tTARGET_LEN: %d\n", target_len);
+            int req_target_len = (int)scsi_req->cmd.xfer;
 
-            if (target_len == 0) {
-                scsi_req_complete(req, GOOD);
+            if (req_target_len == 0) {
+                scsi_req_complete(scsi_req, GOOD);
                 break;
             }
 
-            if (target_len > disk->max_xfer_size) {
-                printf("\tTEST_DISK: error - request too big\n");
+            if (req_target_len > disk->max_xfer_size) {
+                printf("[READ]: target xfer size from request is greater than disk max xfer size\n");
 
-                scsi_req_build_sense(req, SENSE_CODE(INVALID_FIELD));
-                scsi_req_complete(req, CHECK_CONDITION);
+                scsi_req_build_sense(scsi_req, SENSE_CODE(INVALID_FIELD));
+                scsi_req_complete(scsi_req, CHECK_CONDITION);
                 break;
             }
 
-            r->len = target_len;
-            r->timer = timer_new_ms(QEMU_CLOCK_REALTIME, test_disk_read_callback, r);
+            disk_req->response_buf_len = req_target_len;
+            disk_req->timer = timer_new_ms(QEMU_CLOCK_REALTIME, test_disk_read_callback, disk_req);
+
+            // if (qio_channel_write_all(QIO_CHANNEL(disk->socket), (char*)&command, 1, NULL) == 0) {
+            //     delay_ms = 5;
+            // } else {
+            //     printf("[SOCKET]: connection is broken\n");
+            //
+            //     object_unref(OBJECT(disk->socket));
+            //     disk->socket = NULL;
+            //
+            //     test_disk_socket_start_connection(disk);
+            // }
 
-            uint8_t delay_ms = 0;
-            timer_mod(r->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + delay_ms);
+            timer_mod(disk_req->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + disk->latency_ms);
 
-            return 0;
+            break;
 
         default:
-            printf("\tTEST_DISK: rejecting command 0x%02x\n", command);
+            printf("[DISK]: rejecting command 0x%02x\n", command);
 
-            scsi_req_build_sense(req, SENSE_CODE(INVALID_OPCODE));
-            scsi_req_complete(req, CHECK_CONDITION);
+            scsi_req_build_sense(scsi_req, SENSE_CODE(INVALID_OPCODE));
+            scsi_req_complete(scsi_req, CHECK_CONDITION);
             break;
     }
 
     return 0;
 }
 
-static void test_disk_read_data(SCSIRequest* req) {
-    scsi_req_complete(req, GOOD);
+static void test_disk_read_data(SCSIRequest* scsi_req) {
+    scsi_req_complete(scsi_req, GOOD);
 }
 
-static uint8_t* test_disk_get_buf(SCSIRequest* req) {
-    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
-    return r->buf;
+static uint8_t* test_disk_get_buf(SCSIRequest* scsi_req) {
+    TestDiskReq* disk_req = DO_UPCAST(TestDiskReq, parent_scsi_req, scsi_req);
+    return disk_req->response_buf;
 }
 
-static void test_disk_free_req(SCSIRequest* req) {
-    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
 
-    if (r->buf) {
-        g_free(r->buf);
-        r->buf = NULL;
-    }
-}
+// ============================================================================
 
-static const SCSIReqOps test_disk_req_ops = {
-    .size = sizeof(TestDiskReq),
-    .send_command = test_disk_send_command,
-    .read_data = test_disk_read_data,
-    .get_buf = test_disk_get_buf,
-    .free_req = test_disk_free_req
-};
-
-static SCSIRequest* test_disk_alloc_req(SCSIDevice* s, uint32_t tag, uint32_t lun, uint8_t* buf, void* hba_private) {
-    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, s);
-    uint64_t max_xfer_size = disk->max_xfer_size;
 
-    SCSIRequest* req = scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
-    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
+static void test_disk_socket_start_connection(void* opaque) {
+    TestDisk* disk = opaque;
 
-    r->buf = g_malloc0(max_xfer_size);
-
-    return req;
-}
+    if (disk->socket || disk->connecting) {
+        return;
+    }
 
-static void test_disk_realize(SCSIDevice* dev, Error** errp) {
-    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, dev);
+    printf("[SOCKET]: connecting\n");
 
-    dev->type = TYPE_DISK;
-    dev->blocksize = (int)disk->block_size;
+    disk->connecting = true;
+    disk->socket = qio_channel_socket_new();
 
     SocketAddress addr = {
         .type = SOCKET_ADDRESS_TYPE_INET,
@@ -209,30 +203,106 @@ static void test_disk_realize(SCSIDevice* dev, Error** errp) {
         }
     };
 
-    disk->socket = qio_channel_socket_new();
+    qio_channel_socket_connect_async(disk->socket, &addr, test_disk_socket_connected, disk, NULL, NULL);
 
-    if (qio_channel_socket_connect_sync(disk->socket, &addr, NULL) < 0) {
-        printf("SOCKET: failed to connect\n");
+    g_free(addr.u.inet.host);
+    g_free(addr.u.inet.port);
+}
 
+static void test_disk_socket_connected(QIOTask* task, gpointer opaque) {
+    TestDisk* disk = opaque;
+    Error* err = NULL;
+
+    disk->connecting = false;
+
+    if (qio_task_propagate_error(task, &err)) {
+        error_free(err);
         object_unref(OBJECT(disk->socket));
         disk->socket = NULL;
-    } else {
-        printf("SOCKET: connected\n");
+
+        timer_mod(disk->socket_connect_timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 5000);
+        return;
     }
 
-    g_free(addr.u.inet.host);
-    g_free(addr.u.inet.port);
+    uint32_t latency_be = 0;
+    if (qio_channel_read_all(QIO_CHANNEL(disk->socket), (char*) &latency_be, sizeof(latency_be), NULL) < 0) {
+        object_unref(OBJECT(disk->socket));
+        disk->socket = NULL;
+
+        timer_mod(disk->socket_connect_timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 5000);
+        return;
+    }
+
+    disk->latency_ms = be32_to_cpu(latency_be);
+
+    printf("[SOCKET]: connected successfully\n");
+}
+
+static void test_disk_read_callback(void* opaque) {
+    TestDiskReq* req = opaque;
+
+    // read request returns zeros
+    memset(req->response_buf, 0, req->response_buf_len);
+    scsi_req_data(&req->parent_scsi_req, req->response_buf_len);
+
+    timer_free(req->timer);
+    req->timer = NULL;
+}
+
+
+// ============================================================================
+
 
-    printf("TEST_DISK: realized\n");
+static SCSIRequest* test_disk_alloc_req(SCSIDevice* scsi_dev, uint32_t tag, uint32_t lun, uint8_t* request_buf, void* hba_private) {
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_scsi_dev, scsi_dev);
+    uint64_t max_xfer_size = disk->max_xfer_size;
+
+    SCSIRequest* scsi_req = scsi_req_alloc(&test_disk_req_ops, scsi_dev, tag, lun, hba_private);
+    TestDiskReq* disk_req = DO_UPCAST(TestDiskReq, parent_scsi_req, scsi_req);
+
+    disk_req->response_buf = g_malloc0(max_xfer_size);
+
+    return scsi_req;
+}
+
+static void test_disk_free_req(SCSIRequest* scsi_req) {
+    TestDiskReq* disk_req = DO_UPCAST(TestDiskReq, parent_scsi_req, scsi_req);
+
+    if (disk_req->response_buf) {
+        g_free(disk_req->response_buf);
+        disk_req->response_buf = NULL;
+    }
+}
+
+static int test_disk_parse_cdb(SCSIDevice* scsi_dev, SCSICommand* cmd, uint8_t* request_buf, size_t request_buf_len, void* hba_private) {
+    return scsi_req_parse_cdb(scsi_dev, cmd, request_buf, request_buf_len);
 }
 
+static void test_disk_realize(SCSIDevice* scsi_dev, Error** errp) {
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_scsi_dev, scsi_dev);
+
+    scsi_dev->type = TYPE_DISK;
+    scsi_dev->blocksize = (int)disk->block_size;
+
+    disk->latency_ms = 0;
+
+    disk->socket_connect_timer = timer_new_ms(QEMU_CLOCK_REALTIME, test_disk_socket_start_connection, disk);
+    test_disk_socket_start_connection(disk);
+
+    printf("[DISK]: realized\n");
+}
+
+
+// ============================================================================
+
+
 static void test_disk_class_init(ObjectClass* klass, const void* data) {
     DeviceClass* dc = DEVICE_CLASS(klass);
     SCSIDeviceClass* sc = SCSI_DEVICE_CLASS(klass);
 
-    sc->realize = test_disk_realize;
-    sc->parse_cdb = test_disk_parse_cdb;
     sc->alloc_req = test_disk_alloc_req;
+    sc->parse_cdb = test_disk_parse_cdb;
+    sc->realize = test_disk_realize;
 
     set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
     dc->desc = "Test SCSI Disk";
diff --git a/include/hw/scsi/test_disk.h b/hw/scsi/test_disk.h
similarity index 74%
rename from include/hw/scsi/test_disk.h
rename to hw/scsi/test_disk.h
index a86908d965..568f975961 100644
--- a/include/hw/scsi/test_disk.h
+++ b/hw/scsi/test_disk.h
@@ -8,14 +8,20 @@
 #define TYPE_TEST_DISK "test_disk"
 OBJECT_DECLARE_SIMPLE_TYPE(TestDisk, TEST_DISK)
 
+// Device
 struct TestDisk {
-    SCSIDevice parent_obj;
+    SCSIDevice parent_scsi_dev;
     QIOChannelSocket* socket;
 
     uint64_t size;
     uint64_t block_size;
 
     uint64_t max_xfer_size;
+
+    uint32_t latency_ms;
+
+    QEMUTimer* socket_connect_timer;
+    bool connecting;
 };
 
 #endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
-- 
2.52.0

From 262ff0d0d6db6e6404265a494215fd3785bb999e Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Tue, 13 Jan 2026 19:53:51 +0300
Subject: [PATCH 1/7] [ADD] Add test scsi disk

---
 .gitignore                  |  1 +
 hw/scsi/Kconfig             |  5 +++++
 hw/scsi/meson.build         |  1 +
 hw/scsi/test_disk.c         | 38 +++++++++++++++++++++++++++++++++++++
 include/hw/scsi/test_disk.h | 15 +++++++++++++++
 5 files changed, 60 insertions(+)
 create mode 100644 hw/scsi/test_disk.c
 create mode 100644 include/hw/scsi/test_disk.h

diff --git a/.gitignore b/.gitignore
index 61fa39967b..a0687c79d5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,6 +2,7 @@
 /build/
 /.cache/
 /.vscode/
+/.idea/
 *.pyc
 .sdk
 .stgit-*
diff --git a/hw/scsi/Kconfig b/hw/scsi/Kconfig
index 5743ee9b4d..fcc81b304a 100644
--- a/hw/scsi/Kconfig
+++ b/hw/scsi/Kconfig
@@ -69,3 +69,8 @@ config VHOST_USER_SCSI
     default y if VIRTIO_PCI
     select VHOST_SCSI_COMMON
     depends on VIRTIO && VHOST_USER && LINUX
+
+config TEST_DISK
+    bool
+    default y
+    depends on SCSI
diff --git a/hw/scsi/meson.build b/hw/scsi/meson.build
index b874fe1ecd..a45671e646 100644
--- a/hw/scsi/meson.build
+++ b/hw/scsi/meson.build
@@ -16,6 +16,7 @@ scsi_ss.add(when: 'CONFIG_NCR710_SCSI', if_true: files('ncr53c710.c', 'lasi_ncr7
 scsi_ss.add(when: 'CONFIG_MEGASAS_SCSI_PCI', if_true: files('megasas.c'))
 scsi_ss.add(when: 'CONFIG_MPTSAS_SCSI_PCI', if_true: files('mptsas.c', 'mptconfig.c', 'mptendian.c'))
 scsi_ss.add(when: 'CONFIG_VMW_PVSCSI_SCSI_PCI', if_true: files('vmw_pvscsi.c'))
+scsi_ss.add(when: 'CONFIG_TEST_DISK', if_true: files('test_disk.c'))
 
 virtio_scsi_ss.add(files('virtio-scsi-dataplane.c'))
 virtio_scsi_ss.add(when: 'CONFIG_VHOST_SCSI', if_true: files('vhost-scsi.c'))
diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
new file mode 100644
index 0000000000..a8c774182b
--- /dev/null
+++ b/hw/scsi/test_disk.c
@@ -0,0 +1,38 @@
+#include "qemu/osdep.h"
+#include "hw/scsi/test_disk.h"
+#include "hw/scsi/scsi.h"
+#include "qapi/error.h"
+
+static int test_disk_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf, size_t buf_len, void *hba_private) {
+    printf("MySCSIDevice: Received CDB command 0x%02x\n", buf[0]);
+
+    return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
+}
+
+static void test_disk_realize(SCSIDevice *dev, Error **errp) {
+    printf("MySCSIDevice: Device realized (initialized)\n");
+}
+
+static void test_disk_class_init(ObjectClass *klass, const void *data) {
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    SCSIDeviceClass *sc = SCSI_DEVICE_CLASS(klass);
+
+    sc->realize = test_disk_realize;
+    sc->parse_cdb = test_disk_parse_cdb;
+
+    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
+    dc->desc = "Test SCSI Disk";
+}
+
+static const TypeInfo test_disk_info = {
+    .name = TYPE_TEST_DISK,
+    .parent = TYPE_SCSI_DEVICE,
+    .instance_size = sizeof(TestDisk),
+    .class_init = test_disk_class_init,
+};
+
+static void test_disk_register_types(void) {
+    type_register_static(&test_disk_info);
+}
+
+type_init(test_disk_register_types)
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
new file mode 100644
index 0000000000..be2f7ccbd3
--- /dev/null
+++ b/include/hw/scsi/test_disk.h
@@ -0,0 +1,15 @@
+#ifndef HW_SCSI_TEST_DISK_H
+#define HW_SCSI_TEST_DISK_H
+
+#include "hw/scsi/scsi.h"
+#include "qom/object.h"
+
+#define TYPE_TEST_DISK "test_disk"
+OBJECT_DECLARE_SIMPLE_TYPE(TestDisk, TEST_DISK)
+
+struct TestDisk {
+    SCSIDevice parent_obj;
+};
+
+#endif //HW_SCSI_TEST_DISK_H
+./
\ No newline at end of file
-- 
2.52.0


From 6e84f169872c8bd39c363569a22094ad264de2a3 Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Thu, 15 Jan 2026 18:12:16 +0300
Subject: [PATCH 2/7] [ADD] Add basic request handling

---
 hw/scsi/test_disk.c         | 104 +++++++++++++++++++++++++++++++++++-
 include/hw/scsi/test_disk.h |   3 +-
 2 files changed, 103 insertions(+), 4 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index a8c774182b..42a4f220f1 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -2,15 +2,114 @@
 #include "hw/scsi/test_disk.h"
 #include "hw/scsi/scsi.h"
 #include "qapi/error.h"
+#include "scsi/constants.h"
 
 static int test_disk_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf, size_t buf_len, void *hba_private) {
-    printf("MySCSIDevice: Received CDB command 0x%02x\n", buf[0]);
+    printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
 
     return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
 }
 
+typedef struct TestDiskReq {
+    SCSIRequest req;
+    uint8_t buf[256];
+} TestDiskReq;
+
+static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
+    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+    uint8_t command = buf[0];
+    uint8_t* outbuf = r->buf;
+
+    switch (command) {
+        case 0x00:
+            printf("\tTEST_DISK: TEST UNIT READY\n");
+
+            scsi_req_complete(req, GOOD);
+            break;
+
+        case 0x12:
+            printf("\tTEST_DISK: INQUIRY\n");
+            memset(outbuf, 0, 36);
+            outbuf[0] = 0;   // Direct-access block device
+            outbuf[1] = 0;   // non-removable
+            outbuf[2] = 5;   // SPC-3
+            outbuf[3] = 2;   // response data format
+            outbuf[4] = 31;  // additional length
+            memcpy(&outbuf[8],  "QEMU    ", 8);
+            memcpy(&outbuf[16], "TEST_DISK       ", 16);
+
+            scsi_req_data(req, 36);
+            break;
+
+        case 0x25:
+            printf("\tTEST_DISK: READ CAPACITY (10)\n");
+
+            memset(outbuf, 0, 8);
+
+            const uint32_t block_size = 512;
+            const uint32_t total_blocks = 2097152U;
+
+            uint32_t last_lba = total_blocks - 1;
+
+            outbuf[0] = (last_lba >> 24) & 0xff;
+            outbuf[1] = (last_lba >> 16) & 0xff;
+            outbuf[2] = (last_lba >> 8) & 0xff;
+            outbuf[3] = last_lba & 0xff;
+            
+            outbuf[4] = (block_size >> 24) & 0xff;
+            outbuf[5] = (block_size >> 16) & 0xff;
+            outbuf[6] = (block_size >> 8) & 0xff;
+            outbuf[7] = block_size & 0xff;
+            
+            scsi_req_data(req, 8);
+
+            break;
+
+        case 0x1A:
+            printf("\tTEST_DISK: MODE SENSE (6)\n");
+
+            memset(outbuf, 0, 4);
+            outbuf[0] = 3;     // length
+            outbuf[2] = 0x80;  // write protection
+
+            scsi_req_data(req, 4);
+            break;
+
+        default:
+            printf("\tTEST_DISK: rejecting command 0x%02x\n", command);
+
+            scsi_req_build_sense(req, SENSE_CODE(INVALID_OPCODE));
+            scsi_req_complete(req, CHECK_CONDITION);
+
+            break;
+    }
+
+    return 0;
+}
+
+static void test_disk_read_data(SCSIRequest *req) {
+    scsi_req_complete(req, GOOD);
+}
+
+static uint8_t* test_disk_get_buf(SCSIRequest *req)
+{
+    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+    return r->buf;
+}
+
+static const SCSIReqOps test_disk_req_ops = {
+    .size = sizeof(TestDiskReq),
+    .send_command = test_disk_send_command,
+    .read_data = test_disk_read_data,
+    .get_buf = test_disk_get_buf
+};
+
+static SCSIRequest* test_disk_alloc_req(SCSIDevice *s, uint32_t tag, uint32_t lun, uint8_t *buf, void *hba_private) {
+    return scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
+}
+
 static void test_disk_realize(SCSIDevice *dev, Error **errp) {
-    printf("MySCSIDevice: Device realized (initialized)\n");
+    printf("TEST_DISK: realized\n");
 }
 
 static void test_disk_class_init(ObjectClass *klass, const void *data) {
@@ -19,6 +118,7 @@ static void test_disk_class_init(ObjectClass *klass, const void *data) {
 
     sc->realize = test_disk_realize;
     sc->parse_cdb = test_disk_parse_cdb;
+    sc->alloc_req = test_disk_alloc_req;
 
     set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
     dc->desc = "Test SCSI Disk";
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
index be2f7ccbd3..ac9e278372 100644
--- a/include/hw/scsi/test_disk.h
+++ b/include/hw/scsi/test_disk.h
@@ -11,5 +11,4 @@ struct TestDisk {
     SCSIDevice parent_obj;
 };
 
-#endif //HW_SCSI_TEST_DISK_H
-./
\ No newline at end of file
+#endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
-- 
2.52.0


From 30039cdfd25a3706d3736a6fba1630c9125143e0 Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Tue, 20 Jan 2026 20:24:58 +0300
Subject: [PATCH 3/7] [ADD] Add socket connection with server

---
 hw/scsi/test_disk.c         | 72 +++++++++++++++++++++++++------------
 include/hw/scsi/test_disk.h |  2 ++
 2 files changed, 52 insertions(+), 22 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index 42a4f220f1..01481301fa 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -1,10 +1,9 @@
 #include "qemu/osdep.h"
 #include "hw/scsi/test_disk.h"
 #include "hw/scsi/scsi.h"
-#include "qapi/error.h"
 #include "scsi/constants.h"
 
-static int test_disk_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf, size_t buf_len, void *hba_private) {
+static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf, size_t buf_len, void* hba_private) {
     printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
 
     return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
@@ -16,10 +15,16 @@ typedef struct TestDiskReq {
 } TestDiskReq;
 
 static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
-    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, req->dev);
+
     uint8_t command = buf[0];
     uint8_t* outbuf = r->buf;
 
+    if (disk->socket) {
+        qio_channel_write_all(QIO_CHANNEL(disk->socket), (char*)&command, 1, NULL);
+    }
+
     switch (command) {
         case 0x00:
             printf("\tTEST_DISK: TEST UNIT READY\n");
@@ -30,12 +35,12 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
         case 0x12:
             printf("\tTEST_DISK: INQUIRY\n");
             memset(outbuf, 0, 36);
-            outbuf[0] = 0;   // Direct-access block device
-            outbuf[1] = 0;   // non-removable
-            outbuf[2] = 5;   // SPC-3
-            outbuf[3] = 2;   // response data format
-            outbuf[4] = 31;  // additional length
-            memcpy(&outbuf[8],  "QEMU    ", 8);
+            outbuf[0] = 0; // Direct-access block device
+            outbuf[1] = 0; // non-removable
+            outbuf[2] = 5; // SPC-3
+            outbuf[3] = 2; // response data format
+            outbuf[4] = 31; // additional length
+            memcpy(&outbuf[8], "QEMU    ", 8);
             memcpy(&outbuf[16], "TEST_DISK       ", 16);
 
             scsi_req_data(req, 36);
@@ -55,12 +60,12 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             outbuf[1] = (last_lba >> 16) & 0xff;
             outbuf[2] = (last_lba >> 8) & 0xff;
             outbuf[3] = last_lba & 0xff;
-            
+
             outbuf[4] = (block_size >> 24) & 0xff;
             outbuf[5] = (block_size >> 16) & 0xff;
             outbuf[6] = (block_size >> 8) & 0xff;
             outbuf[7] = block_size & 0xff;
-            
+
             scsi_req_data(req, 8);
 
             break;
@@ -69,8 +74,8 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             printf("\tTEST_DISK: MODE SENSE (6)\n");
 
             memset(outbuf, 0, 4);
-            outbuf[0] = 3;     // length
-            outbuf[2] = 0x80;  // write protection
+            outbuf[0] = 3; // length
+            outbuf[2] = 0x80; // write protection
 
             scsi_req_data(req, 4);
             break;
@@ -87,13 +92,12 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
     return 0;
 }
 
-static void test_disk_read_data(SCSIRequest *req) {
+static void test_disk_read_data(SCSIRequest* req) {
     scsi_req_complete(req, GOOD);
 }
 
-static uint8_t* test_disk_get_buf(SCSIRequest *req)
-{
-    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+static uint8_t* test_disk_get_buf(SCSIRequest* req) {
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
     return r->buf;
 }
 
@@ -104,17 +108,41 @@ static const SCSIReqOps test_disk_req_ops = {
     .get_buf = test_disk_get_buf
 };
 
-static SCSIRequest* test_disk_alloc_req(SCSIDevice *s, uint32_t tag, uint32_t lun, uint8_t *buf, void *hba_private) {
+static SCSIRequest* test_disk_alloc_req(SCSIDevice* s, uint32_t tag, uint32_t lun, uint8_t* buf, void* hba_private) {
     return scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
 }
 
-static void test_disk_realize(SCSIDevice *dev, Error **errp) {
+static void test_disk_realize(SCSIDevice* dev, Error** errp) {
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, dev);
+
+    SocketAddress addr = {
+        .type = SOCKET_ADDRESS_TYPE_INET,
+        .u.inet = {
+            .host = g_strdup("127.0.0.1"),
+            .port = g_strdup("31234")
+        }
+    };
+
+    disk->socket = qio_channel_socket_new();
+
+    if (qio_channel_socket_connect_sync(disk->socket, &addr, NULL) < 0) {
+        printf("SOCKET: failed to connect\n");
+
+        object_unref(OBJECT(disk->socket));
+        disk->socket = NULL;
+    } else {
+        printf("SOCKET: connected\n");
+    }
+
+    g_free(addr.u.inet.host);
+    g_free(addr.u.inet.port);
+
     printf("TEST_DISK: realized\n");
 }
 
-static void test_disk_class_init(ObjectClass *klass, const void *data) {
-    DeviceClass *dc = DEVICE_CLASS(klass);
-    SCSIDeviceClass *sc = SCSI_DEVICE_CLASS(klass);
+static void test_disk_class_init(ObjectClass* klass, const void* data) {
+    DeviceClass* dc = DEVICE_CLASS(klass);
+    SCSIDeviceClass* sc = SCSI_DEVICE_CLASS(klass);
 
     sc->realize = test_disk_realize;
     sc->parse_cdb = test_disk_parse_cdb;
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
index ac9e278372..c6a07db5dd 100644
--- a/include/hw/scsi/test_disk.h
+++ b/include/hw/scsi/test_disk.h
@@ -2,6 +2,7 @@
 #define HW_SCSI_TEST_DISK_H
 
 #include "hw/scsi/scsi.h"
+#include "io/channel-socket.h"
 #include "qom/object.h"
 
 #define TYPE_TEST_DISK "test_disk"
@@ -9,6 +10,7 @@ OBJECT_DECLARE_SIMPLE_TYPE(TestDisk, TEST_DISK)
 
 struct TestDisk {
     SCSIDevice parent_obj;
+    QIOChannelSocket* socket;
 };
 
 #endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
-- 
2.52.0


From bdcc99c3fef44623ab515b5fc3db93758ff61c22 Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Wed, 21 Jan 2026 20:00:40 +0300
Subject: [PATCH 4/7] [ADD] Add read command handler with delay

---
 hw/scsi/test_disk.c | 69 ++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 65 insertions(+), 4 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index 01481301fa..a4bf98bf5f 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -3,6 +3,9 @@
 #include "hw/scsi/scsi.h"
 #include "scsi/constants.h"
 
+// block size * max blocks
+#define MAX_READ_XFER_SIZE (512 * 2048) // 1MB
+
 static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf, size_t buf_len, void* hba_private) {
     printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
 
@@ -11,9 +14,25 @@ static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf,
 
 typedef struct TestDiskReq {
     SCSIRequest req;
-    uint8_t buf[256];
+    QEMUTimer* timer;
+    int len;
+    uint8_t buf[MAX_READ_XFER_SIZE];
 } TestDiskReq;
 
+static void test_disk_read_callback(void* opaque) {
+    printf("CALLBACK: from READ command\n");
+
+    TestDiskReq* r = opaque;
+
+    uint8_t* outbuf = r->buf;
+    memset(outbuf, 0, r->len);
+
+    scsi_req_data(&r->req, r->len);
+
+    timer_free(r->timer);
+    r->timer = NULL;
+}
+
 static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
     TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
     TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, req->dev);
@@ -52,7 +71,7 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             memset(outbuf, 0, 8);
 
             const uint32_t block_size = 512;
-            const uint32_t total_blocks = 2097152U;
+            const uint32_t total_blocks = 2048U;
 
             uint32_t last_lba = total_blocks - 1;
 
@@ -67,7 +86,6 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             outbuf[7] = block_size & 0xff;
 
             scsi_req_data(req, 8);
-
             break;
 
         case 0x1A:
@@ -80,12 +98,52 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             scsi_req_data(req, 4);
             break;
 
+        case 0x5A:
+            printf("\tTEST_DISK: MODE SENSE (10)\n");
+            memset(outbuf, 0, 8);
+
+            outbuf[0] = 0;
+            outbuf[1] = 6;
+
+            outbuf[3] = 0x80;
+
+            scsi_req_data(req, 8);
+            break;
+
+        case 0x08:
+        case 0x28:
+            int read_type = command == 0x08 ? 6 : 10;
+            printf("\tTEST_DISK: READ (%d)\n", read_type);
+
+            int target_len = (int)req->cmd.xfer;
+            printf("\tTARGET_LEN: %d\n", target_len);
+
+            if (target_len == 0) {
+                scsi_req_complete(req, GOOD);
+                break;
+            }
+
+            if (target_len > sizeof(r->buf)) {
+                printf("\tTEST_DISK: error - request too big\n");
+
+                scsi_req_build_sense(req, SENSE_CODE(LBA_OUT_OF_RANGE));
+                scsi_req_complete(req, CHECK_CONDITION);
+                break;
+            }
+
+            r->len = target_len;
+            r->timer = timer_new_ms(QEMU_CLOCK_REALTIME, test_disk_read_callback, r);
+
+            uint8_t delay_ms = 0;
+            timer_mod(r->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + delay_ms);
+
+            return 0;
+
         default:
             printf("\tTEST_DISK: rejecting command 0x%02x\n", command);
 
             scsi_req_build_sense(req, SENSE_CODE(INVALID_OPCODE));
             scsi_req_complete(req, CHECK_CONDITION);
-
             break;
     }
 
@@ -113,6 +171,9 @@ static SCSIRequest* test_disk_alloc_req(SCSIDevice* s, uint32_t tag, uint32_t lu
 }
 
 static void test_disk_realize(SCSIDevice* dev, Error** errp) {
+    dev->type = TYPE_DISK;
+    dev->blocksize = 512;
+
     TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, dev);
 
     SocketAddress addr = {
-- 
2.52.0


From c85a868d1b83d6ff5c7b495741d9e593adcf943f Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Thu, 22 Jan 2026 18:37:00 +0300
Subject: [PATCH 5/7] [ADD] Add ability to set constants

---
 hw/scsi/test_disk.c         | 47 +++++++++++++++++++++++++++++--------
 include/hw/scsi/test_disk.h |  5 ++++
 2 files changed, 42 insertions(+), 10 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index a4bf98bf5f..0669c92192 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -16,9 +16,16 @@ typedef struct TestDiskReq {
     SCSIRequest req;
     QEMUTimer* timer;
     int len;
-    uint8_t buf[MAX_READ_XFER_SIZE];
+
+    uint8_t* buf;
 } TestDiskReq;
 
+static Property test_disk_properties[] = {
+    DEFINE_PROP_SIZE("size", TestDisk, size, 1 * 1024 * 1024 * 1024),
+    DEFINE_PROP_SIZE("bs", TestDisk, block_size, 512),
+    DEFINE_PROP_SIZE("max_xfer_size", TestDisk, max_xfer_size, 1 * 1024 * 1024),
+};
+
 static void test_disk_read_callback(void* opaque) {
     printf("CALLBACK: from READ command\n");
 
@@ -70,8 +77,8 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
 
             memset(outbuf, 0, 8);
 
-            const uint32_t block_size = 512;
-            const uint32_t total_blocks = 2048U;
+            const uint32_t block_size = disk->block_size;
+            const uint32_t total_blocks = disk->size / disk->block_size;
 
             uint32_t last_lba = total_blocks - 1;
 
@@ -123,10 +130,10 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
                 break;
             }
 
-            if (target_len > sizeof(r->buf)) {
+            if (target_len > disk->max_xfer_size) {
                 printf("\tTEST_DISK: error - request too big\n");
 
-                scsi_req_build_sense(req, SENSE_CODE(LBA_OUT_OF_RANGE));
+                scsi_req_build_sense(req, SENSE_CODE(INVALID_FIELD));
                 scsi_req_complete(req, CHECK_CONDITION);
                 break;
             }
@@ -159,23 +166,41 @@ static uint8_t* test_disk_get_buf(SCSIRequest* req) {
     return r->buf;
 }
 
+static void test_disk_free_req(SCSIRequest* req) {
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
+
+    if (r->buf) {
+        g_free(r->buf);
+        r->buf = NULL;
+    }
+}
+
 static const SCSIReqOps test_disk_req_ops = {
     .size = sizeof(TestDiskReq),
     .send_command = test_disk_send_command,
     .read_data = test_disk_read_data,
-    .get_buf = test_disk_get_buf
+    .get_buf = test_disk_get_buf,
+    .free_req = test_disk_free_req
 };
 
 static SCSIRequest* test_disk_alloc_req(SCSIDevice* s, uint32_t tag, uint32_t lun, uint8_t* buf, void* hba_private) {
-    return scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, s);
+    uint64_t max_xfer_size = disk->max_xfer_size;
+
+    SCSIRequest* req = scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
+
+    r->buf = g_malloc0(max_xfer_size);
+
+    return req;
 }
 
 static void test_disk_realize(SCSIDevice* dev, Error** errp) {
-    dev->type = TYPE_DISK;
-    dev->blocksize = 512;
-
     TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, dev);
 
+    dev->type = TYPE_DISK;
+    dev->blocksize = (int)disk->block_size;
+
     SocketAddress addr = {
         .type = SOCKET_ADDRESS_TYPE_INET,
         .u.inet = {
@@ -211,6 +236,8 @@ static void test_disk_class_init(ObjectClass* klass, const void* data) {
 
     set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
     dc->desc = "Test SCSI Disk";
+
+    device_class_set_props(dc, test_disk_properties);
 }
 
 static const TypeInfo test_disk_info = {
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
index c6a07db5dd..a86908d965 100644
--- a/include/hw/scsi/test_disk.h
+++ b/include/hw/scsi/test_disk.h
@@ -11,6 +11,11 @@ OBJECT_DECLARE_SIMPLE_TYPE(TestDisk, TEST_DISK)
 struct TestDisk {
     SCSIDevice parent_obj;
     QIOChannelSocket* socket;
+
+    uint64_t size;
+    uint64_t block_size;
+
+    uint64_t max_xfer_size;
 };
 
 #endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
-- 
2.52.0


From 46d1e5f6345471f28022a7df98aee204340c8053 Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Fri, 23 Jan 2026 01:28:47 +0300
Subject: [PATCH 6/7] [REF] Reafactor + async socket connection and
 reconnection mechanism

---
 hw/scsi/test_disk.c                 | 348 +++++++++++++++++-----------
 {include/hw => hw}/scsi/test_disk.h |   8 +-
 2 files changed, 216 insertions(+), 140 deletions(-)
 rename {include/hw => hw}/scsi/test_disk.h (74%)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index 0669c92192..f0262586a9 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -1,205 +1,199 @@
 #include "qemu/osdep.h"
-#include "hw/scsi/test_disk.h"
 #include "hw/scsi/scsi.h"
+#include "test_disk.h"
+#include "qapi/error.h"
 #include "scsi/constants.h"
 
-// block size * max blocks
-#define MAX_READ_XFER_SIZE (512 * 2048) // 1MB
 
-static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf, size_t buf_len, void* hba_private) {
-    printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
+// Device properties
+static const Property test_disk_properties[] = {
+    DEFINE_PROP_SIZE("size", TestDisk, size, 1 * 1024 * 1024 * 1024),
+    DEFINE_PROP_SIZE("bs", TestDisk, block_size, 512),
+    DEFINE_PROP_SIZE("max_xfer_size", TestDisk, max_xfer_size, 1 * 1024 * 1024),
+};
 
-    return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
-}
 
+// Request
 typedef struct TestDiskReq {
-    SCSIRequest req;
+    SCSIRequest parent_scsi_req;
     QEMUTimer* timer;
-    int len;
 
-    uint8_t* buf;
+    uint8_t* response_buf;
+    int response_buf_len;
 } TestDiskReq;
 
-static Property test_disk_properties[] = {
-    DEFINE_PROP_SIZE("size", TestDisk, size, 1 * 1024 * 1024 * 1024),
-    DEFINE_PROP_SIZE("bs", TestDisk, block_size, 512),
-    DEFINE_PROP_SIZE("max_xfer_size", TestDisk, max_xfer_size, 1 * 1024 * 1024),
+
+// Request handlers
+static int32_t test_disk_send_command(SCSIRequest* scsi_req, uint8_t* request_buf);
+static void test_disk_read_data(SCSIRequest* scsi_req);
+static uint8_t* test_disk_get_buf(SCSIRequest* scsi_req);
+static void test_disk_free_req(SCSIRequest* scsi_req);
+
+
+// Request handlers map
+static const SCSIReqOps test_disk_req_ops = {
+    .size = sizeof(TestDiskReq),
+    .send_command = test_disk_send_command,
+    .read_data = test_disk_read_data,
+    .get_buf = test_disk_get_buf,
+    .free_req = test_disk_free_req
 };
 
-static void test_disk_read_callback(void* opaque) {
-    printf("CALLBACK: from READ command\n");
 
-    TestDiskReq* r = opaque;
+// Helper functions
+static void test_disk_socket_start_connection(void* opaque);
+static void test_disk_socket_connected(QIOTask* task, gpointer opaque);
+static void test_disk_read_callback(void* opaque);
 
-    uint8_t* outbuf = r->buf;
-    memset(outbuf, 0, r->len);
 
-    scsi_req_data(&r->req, r->len);
+// ============================================================================
 
-    timer_free(r->timer);
-    r->timer = NULL;
-}
 
-static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
-    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
-    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, req->dev);
+static int32_t test_disk_send_command(SCSIRequest* scsi_req, uint8_t* request_buf) {
+    TestDiskReq* disk_req = DO_UPCAST(TestDiskReq, parent_scsi_req, scsi_req);
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_scsi_dev, scsi_req->dev);
 
-    uint8_t command = buf[0];
-    uint8_t* outbuf = r->buf;
+    uint8_t command = request_buf[0];
 
-    if (disk->socket) {
-        qio_channel_write_all(QIO_CHANNEL(disk->socket), (char*)&command, 1, NULL);
-    }
+    // INQUIRY request is handled even without socket
+    if (command == 0x12) { // INQUIRY
+        memset(disk_req->response_buf, 0, 36);
 
-    switch (command) {
-        case 0x00:
-            printf("\tTEST_DISK: TEST UNIT READY\n");
+        disk_req->response_buf[0] = 0; // Direct-access block device
+        disk_req->response_buf[1] = 0; // non-removable
+        disk_req->response_buf[2] = 5; // SPC-3
+        disk_req->response_buf[3] = 2; // response data format
+        disk_req->response_buf[4] = 31; // additional length
 
-            scsi_req_complete(req, GOOD);
-            break;
+        memcpy(&disk_req->response_buf[8], "QEMU", 4); // vendor
+        memcpy(&disk_req->response_buf[16], "TEST_DISK", 9); // product
 
-        case 0x12:
-            printf("\tTEST_DISK: INQUIRY\n");
-            memset(outbuf, 0, 36);
-            outbuf[0] = 0; // Direct-access block device
-            outbuf[1] = 0; // non-removable
-            outbuf[2] = 5; // SPC-3
-            outbuf[3] = 2; // response data format
-            outbuf[4] = 31; // additional length
-            memcpy(&outbuf[8], "QEMU    ", 8);
-            memcpy(&outbuf[16], "TEST_DISK       ", 16);
-
-            scsi_req_data(req, 36);
-            break;
+        scsi_req_data(scsi_req, 36);
+        return 0;
+    }
 
-        case 0x25:
-            printf("\tTEST_DISK: READ CAPACITY (10)\n");
+    if (!disk->socket) {
+        scsi_req_build_sense(scsi_req, SENSE_CODE(NOT_READY));
+        scsi_req_complete(scsi_req, CHECK_CONDITION);
+        return 0;
+    }
+
+    switch (command) {
+        case 0x00: // TEST UNIT READY
+            scsi_req_complete(scsi_req, GOOD);
+            break;
 
-            memset(outbuf, 0, 8);
+        case 0x25: // READ CAPACITY (10)
+            memset(disk_req->response_buf, 0, 8);
 
             const uint32_t block_size = disk->block_size;
             const uint32_t total_blocks = disk->size / disk->block_size;
 
-            uint32_t last_lba = total_blocks - 1;
+            const uint32_t last_lba = total_blocks - 1;
 
-            outbuf[0] = (last_lba >> 24) & 0xff;
-            outbuf[1] = (last_lba >> 16) & 0xff;
-            outbuf[2] = (last_lba >> 8) & 0xff;
-            outbuf[3] = last_lba & 0xff;
+            disk_req->response_buf[0] = (last_lba >> 24) & 0xff;
+            disk_req->response_buf[1] = (last_lba >> 16) & 0xff;
+            disk_req->response_buf[2] = (last_lba >> 8) & 0xff;
+            disk_req->response_buf[3] = last_lba & 0xff;
 
-            outbuf[4] = (block_size >> 24) & 0xff;
-            outbuf[5] = (block_size >> 16) & 0xff;
-            outbuf[6] = (block_size >> 8) & 0xff;
-            outbuf[7] = block_size & 0xff;
+            disk_req->response_buf[4] = (block_size >> 24) & 0xff;
+            disk_req->response_buf[5] = (block_size >> 16) & 0xff;
+            disk_req->response_buf[6] = (block_size >> 8) & 0xff;
+            disk_req->response_buf[7] = block_size & 0xff;
 
-            scsi_req_data(req, 8);
+            scsi_req_data(scsi_req, 8);
             break;
 
-        case 0x1A:
-            printf("\tTEST_DISK: MODE SENSE (6)\n");
+        case 0x1A: // MODE SENSE (6)
+            memset(disk_req->response_buf, 0, 4);
 
-            memset(outbuf, 0, 4);
-            outbuf[0] = 3; // length
-            outbuf[2] = 0x80; // write protection
+            disk_req->response_buf[0] = 3; // length
+            disk_req->response_buf[2] = 0x80; // write protection
 
-            scsi_req_data(req, 4);
+            scsi_req_data(scsi_req, 4);
             break;
 
-        case 0x5A:
-            printf("\tTEST_DISK: MODE SENSE (10)\n");
-            memset(outbuf, 0, 8);
-
-            outbuf[0] = 0;
-            outbuf[1] = 6;
+        case 0x5A: // MODE SENSE (10)
+            memset(disk_req->response_buf, 0, 8);
 
-            outbuf[3] = 0x80;
+            disk_req->response_buf[0] = 0;
+            disk_req->response_buf[1] = 6;
+            disk_req->response_buf[3] = 0x80;
 
-            scsi_req_data(req, 8);
+            scsi_req_data(scsi_req, 8);
             break;
 
-        case 0x08:
-        case 0x28:
-            int read_type = command == 0x08 ? 6 : 10;
-            printf("\tTEST_DISK: READ (%d)\n", read_type);
+        case 0x08: // READ (6)
+        case 0x28: // READ (10)
 
-            int target_len = (int)req->cmd.xfer;
-            printf("\tTARGET_LEN: %d\n", target_len);
+            int req_target_len = (int)scsi_req->cmd.xfer;
 
-            if (target_len == 0) {
-                scsi_req_complete(req, GOOD);
+            if (req_target_len == 0) {
+                scsi_req_complete(scsi_req, GOOD);
                 break;
             }
 
-            if (target_len > disk->max_xfer_size) {
-                printf("\tTEST_DISK: error - request too big\n");
+            if (req_target_len > disk->max_xfer_size) {
+                printf("[READ]: target xfer size from request is greater than disk max xfer size\n");
 
-                scsi_req_build_sense(req, SENSE_CODE(INVALID_FIELD));
-                scsi_req_complete(req, CHECK_CONDITION);
+                scsi_req_build_sense(scsi_req, SENSE_CODE(INVALID_FIELD));
+                scsi_req_complete(scsi_req, CHECK_CONDITION);
                 break;
             }
 
-            r->len = target_len;
-            r->timer = timer_new_ms(QEMU_CLOCK_REALTIME, test_disk_read_callback, r);
+            disk_req->response_buf_len = req_target_len;
+            disk_req->timer = timer_new_ms(QEMU_CLOCK_REALTIME, test_disk_read_callback, disk_req);
+
+            // if (qio_channel_write_all(QIO_CHANNEL(disk->socket), (char*)&command, 1, NULL) == 0) {
+            //     delay_ms = 5;
+            // } else {
+            //     printf("[SOCKET]: connection is broken\n");
+            //
+            //     object_unref(OBJECT(disk->socket));
+            //     disk->socket = NULL;
+            //
+            //     test_disk_socket_start_connection(disk);
+            // }
 
-            uint8_t delay_ms = 0;
-            timer_mod(r->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + delay_ms);
+            timer_mod(disk_req->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + disk->latency_ms);
 
-            return 0;
+            break;
 
         default:
-            printf("\tTEST_DISK: rejecting command 0x%02x\n", command);
+            printf("[DISK]: rejecting command 0x%02x\n", command);
 
-            scsi_req_build_sense(req, SENSE_CODE(INVALID_OPCODE));
-            scsi_req_complete(req, CHECK_CONDITION);
+            scsi_req_build_sense(scsi_req, SENSE_CODE(INVALID_OPCODE));
+            scsi_req_complete(scsi_req, CHECK_CONDITION);
             break;
     }
 
     return 0;
 }
 
-static void test_disk_read_data(SCSIRequest* req) {
-    scsi_req_complete(req, GOOD);
+static void test_disk_read_data(SCSIRequest* scsi_req) {
+    scsi_req_complete(scsi_req, GOOD);
 }
 
-static uint8_t* test_disk_get_buf(SCSIRequest* req) {
-    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
-    return r->buf;
+static uint8_t* test_disk_get_buf(SCSIRequest* scsi_req) {
+    TestDiskReq* disk_req = DO_UPCAST(TestDiskReq, parent_scsi_req, scsi_req);
+    return disk_req->response_buf;
 }
 
-static void test_disk_free_req(SCSIRequest* req) {
-    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
 
-    if (r->buf) {
-        g_free(r->buf);
-        r->buf = NULL;
-    }
-}
+// ============================================================================
 
-static const SCSIReqOps test_disk_req_ops = {
-    .size = sizeof(TestDiskReq),
-    .send_command = test_disk_send_command,
-    .read_data = test_disk_read_data,
-    .get_buf = test_disk_get_buf,
-    .free_req = test_disk_free_req
-};
-
-static SCSIRequest* test_disk_alloc_req(SCSIDevice* s, uint32_t tag, uint32_t lun, uint8_t* buf, void* hba_private) {
-    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, s);
-    uint64_t max_xfer_size = disk->max_xfer_size;
 
-    SCSIRequest* req = scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
-    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
+static void test_disk_socket_start_connection(void* opaque) {
+    TestDisk* disk = opaque;
 
-    r->buf = g_malloc0(max_xfer_size);
-
-    return req;
-}
+    if (disk->socket || disk->connecting) {
+        return;
+    }
 
-static void test_disk_realize(SCSIDevice* dev, Error** errp) {
-    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, dev);
+    printf("[SOCKET]: connecting\n");
 
-    dev->type = TYPE_DISK;
-    dev->blocksize = (int)disk->block_size;
+    disk->connecting = true;
+    disk->socket = qio_channel_socket_new();
 
     SocketAddress addr = {
         .type = SOCKET_ADDRESS_TYPE_INET,
@@ -209,30 +203,106 @@ static void test_disk_realize(SCSIDevice* dev, Error** errp) {
         }
     };
 
-    disk->socket = qio_channel_socket_new();
+    qio_channel_socket_connect_async(disk->socket, &addr, test_disk_socket_connected, disk, NULL, NULL);
 
-    if (qio_channel_socket_connect_sync(disk->socket, &addr, NULL) < 0) {
-        printf("SOCKET: failed to connect\n");
+    g_free(addr.u.inet.host);
+    g_free(addr.u.inet.port);
+}
 
+static void test_disk_socket_connected(QIOTask* task, gpointer opaque) {
+    TestDisk* disk = opaque;
+    Error* err = NULL;
+
+    disk->connecting = false;
+
+    if (qio_task_propagate_error(task, &err)) {
+        error_free(err);
         object_unref(OBJECT(disk->socket));
         disk->socket = NULL;
-    } else {
-        printf("SOCKET: connected\n");
+
+        timer_mod(disk->socket_connect_timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 5000);
+        return;
     }
 
-    g_free(addr.u.inet.host);
-    g_free(addr.u.inet.port);
+    uint32_t latency_be = 0;
+    if (qio_channel_read_all(QIO_CHANNEL(disk->socket), (char*) &latency_be, sizeof(latency_be), NULL) < 0) {
+        object_unref(OBJECT(disk->socket));
+        disk->socket = NULL;
+
+        timer_mod(disk->socket_connect_timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 5000);
+        return;
+    }
+
+    disk->latency_ms = be32_to_cpu(latency_be);
+
+    printf("[SOCKET]: connected successfully\n");
+}
+
+static void test_disk_read_callback(void* opaque) {
+    TestDiskReq* req = opaque;
+
+    // read request returns zeros
+    memset(req->response_buf, 0, req->response_buf_len);
+    scsi_req_data(&req->parent_scsi_req, req->response_buf_len);
+
+    timer_free(req->timer);
+    req->timer = NULL;
+}
+
+
+// ============================================================================
+
 
-    printf("TEST_DISK: realized\n");
+static SCSIRequest* test_disk_alloc_req(SCSIDevice* scsi_dev, uint32_t tag, uint32_t lun, uint8_t* request_buf, void* hba_private) {
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_scsi_dev, scsi_dev);
+    uint64_t max_xfer_size = disk->max_xfer_size;
+
+    SCSIRequest* scsi_req = scsi_req_alloc(&test_disk_req_ops, scsi_dev, tag, lun, hba_private);
+    TestDiskReq* disk_req = DO_UPCAST(TestDiskReq, parent_scsi_req, scsi_req);
+
+    disk_req->response_buf = g_malloc0(max_xfer_size);
+
+    return scsi_req;
+}
+
+static void test_disk_free_req(SCSIRequest* scsi_req) {
+    TestDiskReq* disk_req = DO_UPCAST(TestDiskReq, parent_scsi_req, scsi_req);
+
+    if (disk_req->response_buf) {
+        g_free(disk_req->response_buf);
+        disk_req->response_buf = NULL;
+    }
+}
+
+static int test_disk_parse_cdb(SCSIDevice* scsi_dev, SCSICommand* cmd, uint8_t* request_buf, size_t request_buf_len, void* hba_private) {
+    return scsi_req_parse_cdb(scsi_dev, cmd, request_buf, request_buf_len);
 }
 
+static void test_disk_realize(SCSIDevice* scsi_dev, Error** errp) {
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_scsi_dev, scsi_dev);
+
+    scsi_dev->type = TYPE_DISK;
+    scsi_dev->blocksize = (int)disk->block_size;
+
+    disk->latency_ms = 0;
+
+    disk->socket_connect_timer = timer_new_ms(QEMU_CLOCK_REALTIME, test_disk_socket_start_connection, disk);
+    test_disk_socket_start_connection(disk);
+
+    printf("[DISK]: realized\n");
+}
+
+
+// ============================================================================
+
+
 static void test_disk_class_init(ObjectClass* klass, const void* data) {
     DeviceClass* dc = DEVICE_CLASS(klass);
     SCSIDeviceClass* sc = SCSI_DEVICE_CLASS(klass);
 
-    sc->realize = test_disk_realize;
-    sc->parse_cdb = test_disk_parse_cdb;
     sc->alloc_req = test_disk_alloc_req;
+    sc->parse_cdb = test_disk_parse_cdb;
+    sc->realize = test_disk_realize;
 
     set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
     dc->desc = "Test SCSI Disk";
diff --git a/include/hw/scsi/test_disk.h b/hw/scsi/test_disk.h
similarity index 74%
rename from include/hw/scsi/test_disk.h
rename to hw/scsi/test_disk.h
index a86908d965..568f975961 100644
--- a/include/hw/scsi/test_disk.h
+++ b/hw/scsi/test_disk.h
@@ -8,14 +8,20 @@
 #define TYPE_TEST_DISK "test_disk"
 OBJECT_DECLARE_SIMPLE_TYPE(TestDisk, TEST_DISK)
 
+// Device
 struct TestDisk {
-    SCSIDevice parent_obj;
+    SCSIDevice parent_scsi_dev;
     QIOChannelSocket* socket;
 
     uint64_t size;
     uint64_t block_size;
 
     uint64_t max_xfer_size;
+
+    uint32_t latency_ms;
+
+    QEMUTimer* socket_connect_timer;
+    bool connecting;
 };
 
 #endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
-- 
2.52.0


From 945c5fb1ac2e7052968cab7f613f040dc6d409fc Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Fri, 23 Jan 2026 12:55:40 +0300
Subject: [PATCH 7/7] [REF] Minor refactoring

---
 hw/scsi/test_disk.c | 23 +++++------------------
 hw/scsi/test_disk.h |  2 --
 2 files changed, 5 insertions(+), 20 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index f0262586a9..a7fa2a4a77 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -4,12 +4,13 @@
 #include "qapi/error.h"
 #include "scsi/constants.h"
 
+#define MAX_XFER_SIZE (1 * 1024 * 1024)
+
 
 // Device properties
 static const Property test_disk_properties[] = {
     DEFINE_PROP_SIZE("size", TestDisk, size, 1 * 1024 * 1024 * 1024),
     DEFINE_PROP_SIZE("bs", TestDisk, block_size, 512),
-    DEFINE_PROP_SIZE("max_xfer_size", TestDisk, max_xfer_size, 1 * 1024 * 1024),
 };
 
 
@@ -133,7 +134,7 @@ static int32_t test_disk_send_command(SCSIRequest* scsi_req, uint8_t* request_bu
                 break;
             }
 
-            if (req_target_len > disk->max_xfer_size) {
+            if (req_target_len > MAX_XFER_SIZE) {
                 printf("[READ]: target xfer size from request is greater than disk max xfer size\n");
 
                 scsi_req_build_sense(scsi_req, SENSE_CODE(INVALID_FIELD));
@@ -144,17 +145,6 @@ static int32_t test_disk_send_command(SCSIRequest* scsi_req, uint8_t* request_bu
             disk_req->response_buf_len = req_target_len;
             disk_req->timer = timer_new_ms(QEMU_CLOCK_REALTIME, test_disk_read_callback, disk_req);
 
-            // if (qio_channel_write_all(QIO_CHANNEL(disk->socket), (char*)&command, 1, NULL) == 0) {
-            //     delay_ms = 5;
-            // } else {
-            //     printf("[SOCKET]: connection is broken\n");
-            //
-            //     object_unref(OBJECT(disk->socket));
-            //     disk->socket = NULL;
-            //
-            //     test_disk_socket_start_connection(disk);
-            // }
-
             timer_mod(disk_req->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + disk->latency_ms);
 
             break;
@@ -235,7 +225,7 @@ static void test_disk_socket_connected(QIOTask* task, gpointer opaque) {
 
     disk->latency_ms = be32_to_cpu(latency_be);
 
-    printf("[SOCKET]: connected successfully\n");
+    printf("[SOCKET]: connected successfully. latency: %dms\n", disk->latency_ms);
 }
 
 static void test_disk_read_callback(void* opaque) {
@@ -254,13 +244,10 @@ static void test_disk_read_callback(void* opaque) {
 
 
 static SCSIRequest* test_disk_alloc_req(SCSIDevice* scsi_dev, uint32_t tag, uint32_t lun, uint8_t* request_buf, void* hba_private) {
-    TestDisk* disk = DO_UPCAST(TestDisk, parent_scsi_dev, scsi_dev);
-    uint64_t max_xfer_size = disk->max_xfer_size;
-
     SCSIRequest* scsi_req = scsi_req_alloc(&test_disk_req_ops, scsi_dev, tag, lun, hba_private);
     TestDiskReq* disk_req = DO_UPCAST(TestDiskReq, parent_scsi_req, scsi_req);
 
-    disk_req->response_buf = g_malloc0(max_xfer_size);
+    disk_req->response_buf = g_malloc0(MAX_XFER_SIZE);
 
     return scsi_req;
 }
diff --git a/hw/scsi/test_disk.h b/hw/scsi/test_disk.h
index 568f975961..91aecea9b1 100644
--- a/hw/scsi/test_disk.h
+++ b/hw/scsi/test_disk.h
@@ -16,8 +16,6 @@ struct TestDisk {
     uint64_t size;
     uint64_t block_size;
 
-    uint64_t max_xfer_size;
-
     uint32_t latency_ms;
 
     QEMUTimer* socket_connect_timer;
-- 
2.52.0

From 262ff0d0d6db6e6404265a494215fd3785bb999e Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Tue, 13 Jan 2026 19:53:51 +0300
Subject: [PATCH 1/8] [ADD] Add test scsi disk

---
 .gitignore                  |  1 +
 hw/scsi/Kconfig             |  5 +++++
 hw/scsi/meson.build         |  1 +
 hw/scsi/test_disk.c         | 38 +++++++++++++++++++++++++++++++++++++
 include/hw/scsi/test_disk.h | 15 +++++++++++++++
 5 files changed, 60 insertions(+)
 create mode 100644 hw/scsi/test_disk.c
 create mode 100644 include/hw/scsi/test_disk.h

diff --git a/.gitignore b/.gitignore
index 61fa39967b..a0687c79d5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,6 +2,7 @@
 /build/
 /.cache/
 /.vscode/
+/.idea/
 *.pyc
 .sdk
 .stgit-*
diff --git a/hw/scsi/Kconfig b/hw/scsi/Kconfig
index 5743ee9b4d..fcc81b304a 100644
--- a/hw/scsi/Kconfig
+++ b/hw/scsi/Kconfig
@@ -69,3 +69,8 @@ config VHOST_USER_SCSI
     default y if VIRTIO_PCI
     select VHOST_SCSI_COMMON
     depends on VIRTIO && VHOST_USER && LINUX
+
+config TEST_DISK
+    bool
+    default y
+    depends on SCSI
diff --git a/hw/scsi/meson.build b/hw/scsi/meson.build
index b874fe1ecd..a45671e646 100644
--- a/hw/scsi/meson.build
+++ b/hw/scsi/meson.build
@@ -16,6 +16,7 @@ scsi_ss.add(when: 'CONFIG_NCR710_SCSI', if_true: files('ncr53c710.c', 'lasi_ncr7
 scsi_ss.add(when: 'CONFIG_MEGASAS_SCSI_PCI', if_true: files('megasas.c'))
 scsi_ss.add(when: 'CONFIG_MPTSAS_SCSI_PCI', if_true: files('mptsas.c', 'mptconfig.c', 'mptendian.c'))
 scsi_ss.add(when: 'CONFIG_VMW_PVSCSI_SCSI_PCI', if_true: files('vmw_pvscsi.c'))
+scsi_ss.add(when: 'CONFIG_TEST_DISK', if_true: files('test_disk.c'))
 
 virtio_scsi_ss.add(files('virtio-scsi-dataplane.c'))
 virtio_scsi_ss.add(when: 'CONFIG_VHOST_SCSI', if_true: files('vhost-scsi.c'))
diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
new file mode 100644
index 0000000000..a8c774182b
--- /dev/null
+++ b/hw/scsi/test_disk.c
@@ -0,0 +1,38 @@
+#include "qemu/osdep.h"
+#include "hw/scsi/test_disk.h"
+#include "hw/scsi/scsi.h"
+#include "qapi/error.h"
+
+static int test_disk_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf, size_t buf_len, void *hba_private) {
+    printf("MySCSIDevice: Received CDB command 0x%02x\n", buf[0]);
+
+    return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
+}
+
+static void test_disk_realize(SCSIDevice *dev, Error **errp) {
+    printf("MySCSIDevice: Device realized (initialized)\n");
+}
+
+static void test_disk_class_init(ObjectClass *klass, const void *data) {
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    SCSIDeviceClass *sc = SCSI_DEVICE_CLASS(klass);
+
+    sc->realize = test_disk_realize;
+    sc->parse_cdb = test_disk_parse_cdb;
+
+    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
+    dc->desc = "Test SCSI Disk";
+}
+
+static const TypeInfo test_disk_info = {
+    .name = TYPE_TEST_DISK,
+    .parent = TYPE_SCSI_DEVICE,
+    .instance_size = sizeof(TestDisk),
+    .class_init = test_disk_class_init,
+};
+
+static void test_disk_register_types(void) {
+    type_register_static(&test_disk_info);
+}
+
+type_init(test_disk_register_types)
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
new file mode 100644
index 0000000000..be2f7ccbd3
--- /dev/null
+++ b/include/hw/scsi/test_disk.h
@@ -0,0 +1,15 @@
+#ifndef HW_SCSI_TEST_DISK_H
+#define HW_SCSI_TEST_DISK_H
+
+#include "hw/scsi/scsi.h"
+#include "qom/object.h"
+
+#define TYPE_TEST_DISK "test_disk"
+OBJECT_DECLARE_SIMPLE_TYPE(TestDisk, TEST_DISK)
+
+struct TestDisk {
+    SCSIDevice parent_obj;
+};
+
+#endif //HW_SCSI_TEST_DISK_H
+./
\ No newline at end of file
-- 
2.52.0


From 6e84f169872c8bd39c363569a22094ad264de2a3 Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Thu, 15 Jan 2026 18:12:16 +0300
Subject: [PATCH 2/8] [ADD] Add basic request handling

---
 hw/scsi/test_disk.c         | 104 +++++++++++++++++++++++++++++++++++-
 include/hw/scsi/test_disk.h |   3 +-
 2 files changed, 103 insertions(+), 4 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index a8c774182b..42a4f220f1 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -2,15 +2,114 @@
 #include "hw/scsi/test_disk.h"
 #include "hw/scsi/scsi.h"
 #include "qapi/error.h"
+#include "scsi/constants.h"
 
 static int test_disk_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf, size_t buf_len, void *hba_private) {
-    printf("MySCSIDevice: Received CDB command 0x%02x\n", buf[0]);
+    printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
 
     return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
 }
 
+typedef struct TestDiskReq {
+    SCSIRequest req;
+    uint8_t buf[256];
+} TestDiskReq;
+
+static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
+    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+    uint8_t command = buf[0];
+    uint8_t* outbuf = r->buf;
+
+    switch (command) {
+        case 0x00:
+            printf("\tTEST_DISK: TEST UNIT READY\n");
+
+            scsi_req_complete(req, GOOD);
+            break;
+
+        case 0x12:
+            printf("\tTEST_DISK: INQUIRY\n");
+            memset(outbuf, 0, 36);
+            outbuf[0] = 0;   // Direct-access block device
+            outbuf[1] = 0;   // non-removable
+            outbuf[2] = 5;   // SPC-3
+            outbuf[3] = 2;   // response data format
+            outbuf[4] = 31;  // additional length
+            memcpy(&outbuf[8],  "QEMU    ", 8);
+            memcpy(&outbuf[16], "TEST_DISK       ", 16);
+
+            scsi_req_data(req, 36);
+            break;
+
+        case 0x25:
+            printf("\tTEST_DISK: READ CAPACITY (10)\n");
+
+            memset(outbuf, 0, 8);
+
+            const uint32_t block_size = 512;
+            const uint32_t total_blocks = 2097152U;
+
+            uint32_t last_lba = total_blocks - 1;
+
+            outbuf[0] = (last_lba >> 24) & 0xff;
+            outbuf[1] = (last_lba >> 16) & 0xff;
+            outbuf[2] = (last_lba >> 8) & 0xff;
+            outbuf[3] = last_lba & 0xff;
+            
+            outbuf[4] = (block_size >> 24) & 0xff;
+            outbuf[5] = (block_size >> 16) & 0xff;
+            outbuf[6] = (block_size >> 8) & 0xff;
+            outbuf[7] = block_size & 0xff;
+            
+            scsi_req_data(req, 8);
+
+            break;
+
+        case 0x1A:
+            printf("\tTEST_DISK: MODE SENSE (6)\n");
+
+            memset(outbuf, 0, 4);
+            outbuf[0] = 3;     // length
+            outbuf[2] = 0x80;  // write protection
+
+            scsi_req_data(req, 4);
+            break;
+
+        default:
+            printf("\tTEST_DISK: rejecting command 0x%02x\n", command);
+
+            scsi_req_build_sense(req, SENSE_CODE(INVALID_OPCODE));
+            scsi_req_complete(req, CHECK_CONDITION);
+
+            break;
+    }
+
+    return 0;
+}
+
+static void test_disk_read_data(SCSIRequest *req) {
+    scsi_req_complete(req, GOOD);
+}
+
+static uint8_t* test_disk_get_buf(SCSIRequest *req)
+{
+    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+    return r->buf;
+}
+
+static const SCSIReqOps test_disk_req_ops = {
+    .size = sizeof(TestDiskReq),
+    .send_command = test_disk_send_command,
+    .read_data = test_disk_read_data,
+    .get_buf = test_disk_get_buf
+};
+
+static SCSIRequest* test_disk_alloc_req(SCSIDevice *s, uint32_t tag, uint32_t lun, uint8_t *buf, void *hba_private) {
+    return scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
+}
+
 static void test_disk_realize(SCSIDevice *dev, Error **errp) {
-    printf("MySCSIDevice: Device realized (initialized)\n");
+    printf("TEST_DISK: realized\n");
 }
 
 static void test_disk_class_init(ObjectClass *klass, const void *data) {
@@ -19,6 +118,7 @@ static void test_disk_class_init(ObjectClass *klass, const void *data) {
 
     sc->realize = test_disk_realize;
     sc->parse_cdb = test_disk_parse_cdb;
+    sc->alloc_req = test_disk_alloc_req;
 
     set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
     dc->desc = "Test SCSI Disk";
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
index be2f7ccbd3..ac9e278372 100644
--- a/include/hw/scsi/test_disk.h
+++ b/include/hw/scsi/test_disk.h
@@ -11,5 +11,4 @@ struct TestDisk {
     SCSIDevice parent_obj;
 };
 
-#endif //HW_SCSI_TEST_DISK_H
-./
\ No newline at end of file
+#endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
-- 
2.52.0


From 30039cdfd25a3706d3736a6fba1630c9125143e0 Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Tue, 20 Jan 2026 20:24:58 +0300
Subject: [PATCH 3/8] [ADD] Add socket connection with server

---
 hw/scsi/test_disk.c         | 72 +++++++++++++++++++++++++------------
 include/hw/scsi/test_disk.h |  2 ++
 2 files changed, 52 insertions(+), 22 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index 42a4f220f1..01481301fa 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -1,10 +1,9 @@
 #include "qemu/osdep.h"
 #include "hw/scsi/test_disk.h"
 #include "hw/scsi/scsi.h"
-#include "qapi/error.h"
 #include "scsi/constants.h"
 
-static int test_disk_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf, size_t buf_len, void *hba_private) {
+static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf, size_t buf_len, void* hba_private) {
     printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
 
     return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
@@ -16,10 +15,16 @@ typedef struct TestDiskReq {
 } TestDiskReq;
 
 static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
-    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, req->dev);
+
     uint8_t command = buf[0];
     uint8_t* outbuf = r->buf;
 
+    if (disk->socket) {
+        qio_channel_write_all(QIO_CHANNEL(disk->socket), (char*)&command, 1, NULL);
+    }
+
     switch (command) {
         case 0x00:
             printf("\tTEST_DISK: TEST UNIT READY\n");
@@ -30,12 +35,12 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
         case 0x12:
             printf("\tTEST_DISK: INQUIRY\n");
             memset(outbuf, 0, 36);
-            outbuf[0] = 0;   // Direct-access block device
-            outbuf[1] = 0;   // non-removable
-            outbuf[2] = 5;   // SPC-3
-            outbuf[3] = 2;   // response data format
-            outbuf[4] = 31;  // additional length
-            memcpy(&outbuf[8],  "QEMU    ", 8);
+            outbuf[0] = 0; // Direct-access block device
+            outbuf[1] = 0; // non-removable
+            outbuf[2] = 5; // SPC-3
+            outbuf[3] = 2; // response data format
+            outbuf[4] = 31; // additional length
+            memcpy(&outbuf[8], "QEMU    ", 8);
             memcpy(&outbuf[16], "TEST_DISK       ", 16);
 
             scsi_req_data(req, 36);
@@ -55,12 +60,12 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             outbuf[1] = (last_lba >> 16) & 0xff;
             outbuf[2] = (last_lba >> 8) & 0xff;
             outbuf[3] = last_lba & 0xff;
-            
+
             outbuf[4] = (block_size >> 24) & 0xff;
             outbuf[5] = (block_size >> 16) & 0xff;
             outbuf[6] = (block_size >> 8) & 0xff;
             outbuf[7] = block_size & 0xff;
-            
+
             scsi_req_data(req, 8);
 
             break;
@@ -69,8 +74,8 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             printf("\tTEST_DISK: MODE SENSE (6)\n");
 
             memset(outbuf, 0, 4);
-            outbuf[0] = 3;     // length
-            outbuf[2] = 0x80;  // write protection
+            outbuf[0] = 3; // length
+            outbuf[2] = 0x80; // write protection
 
             scsi_req_data(req, 4);
             break;
@@ -87,13 +92,12 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
     return 0;
 }
 
-static void test_disk_read_data(SCSIRequest *req) {
+static void test_disk_read_data(SCSIRequest* req) {
     scsi_req_complete(req, GOOD);
 }
 
-static uint8_t* test_disk_get_buf(SCSIRequest *req)
-{
-    TestDiskReq *r = DO_UPCAST(TestDiskReq, req, req);
+static uint8_t* test_disk_get_buf(SCSIRequest* req) {
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
     return r->buf;
 }
 
@@ -104,17 +108,41 @@ static const SCSIReqOps test_disk_req_ops = {
     .get_buf = test_disk_get_buf
 };
 
-static SCSIRequest* test_disk_alloc_req(SCSIDevice *s, uint32_t tag, uint32_t lun, uint8_t *buf, void *hba_private) {
+static SCSIRequest* test_disk_alloc_req(SCSIDevice* s, uint32_t tag, uint32_t lun, uint8_t* buf, void* hba_private) {
     return scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
 }
 
-static void test_disk_realize(SCSIDevice *dev, Error **errp) {
+static void test_disk_realize(SCSIDevice* dev, Error** errp) {
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, dev);
+
+    SocketAddress addr = {
+        .type = SOCKET_ADDRESS_TYPE_INET,
+        .u.inet = {
+            .host = g_strdup("127.0.0.1"),
+            .port = g_strdup("31234")
+        }
+    };
+
+    disk->socket = qio_channel_socket_new();
+
+    if (qio_channel_socket_connect_sync(disk->socket, &addr, NULL) < 0) {
+        printf("SOCKET: failed to connect\n");
+
+        object_unref(OBJECT(disk->socket));
+        disk->socket = NULL;
+    } else {
+        printf("SOCKET: connected\n");
+    }
+
+    g_free(addr.u.inet.host);
+    g_free(addr.u.inet.port);
+
     printf("TEST_DISK: realized\n");
 }
 
-static void test_disk_class_init(ObjectClass *klass, const void *data) {
-    DeviceClass *dc = DEVICE_CLASS(klass);
-    SCSIDeviceClass *sc = SCSI_DEVICE_CLASS(klass);
+static void test_disk_class_init(ObjectClass* klass, const void* data) {
+    DeviceClass* dc = DEVICE_CLASS(klass);
+    SCSIDeviceClass* sc = SCSI_DEVICE_CLASS(klass);
 
     sc->realize = test_disk_realize;
     sc->parse_cdb = test_disk_parse_cdb;
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
index ac9e278372..c6a07db5dd 100644
--- a/include/hw/scsi/test_disk.h
+++ b/include/hw/scsi/test_disk.h
@@ -2,6 +2,7 @@
 #define HW_SCSI_TEST_DISK_H
 
 #include "hw/scsi/scsi.h"
+#include "io/channel-socket.h"
 #include "qom/object.h"
 
 #define TYPE_TEST_DISK "test_disk"
@@ -9,6 +10,7 @@ OBJECT_DECLARE_SIMPLE_TYPE(TestDisk, TEST_DISK)
 
 struct TestDisk {
     SCSIDevice parent_obj;
+    QIOChannelSocket* socket;
 };
 
 #endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
-- 
2.52.0


From bdcc99c3fef44623ab515b5fc3db93758ff61c22 Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Wed, 21 Jan 2026 20:00:40 +0300
Subject: [PATCH 4/8] [ADD] Add read command handler with delay

---
 hw/scsi/test_disk.c | 69 ++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 65 insertions(+), 4 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index 01481301fa..a4bf98bf5f 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -3,6 +3,9 @@
 #include "hw/scsi/scsi.h"
 #include "scsi/constants.h"
 
+// block size * max blocks
+#define MAX_READ_XFER_SIZE (512 * 2048) // 1MB
+
 static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf, size_t buf_len, void* hba_private) {
     printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
 
@@ -11,9 +14,25 @@ static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf,
 
 typedef struct TestDiskReq {
     SCSIRequest req;
-    uint8_t buf[256];
+    QEMUTimer* timer;
+    int len;
+    uint8_t buf[MAX_READ_XFER_SIZE];
 } TestDiskReq;
 
+static void test_disk_read_callback(void* opaque) {
+    printf("CALLBACK: from READ command\n");
+
+    TestDiskReq* r = opaque;
+
+    uint8_t* outbuf = r->buf;
+    memset(outbuf, 0, r->len);
+
+    scsi_req_data(&r->req, r->len);
+
+    timer_free(r->timer);
+    r->timer = NULL;
+}
+
 static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
     TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
     TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, req->dev);
@@ -52,7 +71,7 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             memset(outbuf, 0, 8);
 
             const uint32_t block_size = 512;
-            const uint32_t total_blocks = 2097152U;
+            const uint32_t total_blocks = 2048U;
 
             uint32_t last_lba = total_blocks - 1;
 
@@ -67,7 +86,6 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             outbuf[7] = block_size & 0xff;
 
             scsi_req_data(req, 8);
-
             break;
 
         case 0x1A:
@@ -80,12 +98,52 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
             scsi_req_data(req, 4);
             break;
 
+        case 0x5A:
+            printf("\tTEST_DISK: MODE SENSE (10)\n");
+            memset(outbuf, 0, 8);
+
+            outbuf[0] = 0;
+            outbuf[1] = 6;
+
+            outbuf[3] = 0x80;
+
+            scsi_req_data(req, 8);
+            break;
+
+        case 0x08:
+        case 0x28:
+            int read_type = command == 0x08 ? 6 : 10;
+            printf("\tTEST_DISK: READ (%d)\n", read_type);
+
+            int target_len = (int)req->cmd.xfer;
+            printf("\tTARGET_LEN: %d\n", target_len);
+
+            if (target_len == 0) {
+                scsi_req_complete(req, GOOD);
+                break;
+            }
+
+            if (target_len > sizeof(r->buf)) {
+                printf("\tTEST_DISK: error - request too big\n");
+
+                scsi_req_build_sense(req, SENSE_CODE(LBA_OUT_OF_RANGE));
+                scsi_req_complete(req, CHECK_CONDITION);
+                break;
+            }
+
+            r->len = target_len;
+            r->timer = timer_new_ms(QEMU_CLOCK_REALTIME, test_disk_read_callback, r);
+
+            uint8_t delay_ms = 0;
+            timer_mod(r->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + delay_ms);
+
+            return 0;
+
         default:
             printf("\tTEST_DISK: rejecting command 0x%02x\n", command);
 
             scsi_req_build_sense(req, SENSE_CODE(INVALID_OPCODE));
             scsi_req_complete(req, CHECK_CONDITION);
-
             break;
     }
 
@@ -113,6 +171,9 @@ static SCSIRequest* test_disk_alloc_req(SCSIDevice* s, uint32_t tag, uint32_t lu
 }
 
 static void test_disk_realize(SCSIDevice* dev, Error** errp) {
+    dev->type = TYPE_DISK;
+    dev->blocksize = 512;
+
     TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, dev);
 
     SocketAddress addr = {
-- 
2.52.0


From c85a868d1b83d6ff5c7b495741d9e593adcf943f Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Thu, 22 Jan 2026 18:37:00 +0300
Subject: [PATCH 5/8] [ADD] Add ability to set constants

---
 hw/scsi/test_disk.c         | 47 +++++++++++++++++++++++++++++--------
 include/hw/scsi/test_disk.h |  5 ++++
 2 files changed, 42 insertions(+), 10 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index a4bf98bf5f..0669c92192 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -16,9 +16,16 @@ typedef struct TestDiskReq {
     SCSIRequest req;
     QEMUTimer* timer;
     int len;
-    uint8_t buf[MAX_READ_XFER_SIZE];
+
+    uint8_t* buf;
 } TestDiskReq;
 
+static Property test_disk_properties[] = {
+    DEFINE_PROP_SIZE("size", TestDisk, size, 1 * 1024 * 1024 * 1024),
+    DEFINE_PROP_SIZE("bs", TestDisk, block_size, 512),
+    DEFINE_PROP_SIZE("max_xfer_size", TestDisk, max_xfer_size, 1 * 1024 * 1024),
+};
+
 static void test_disk_read_callback(void* opaque) {
     printf("CALLBACK: from READ command\n");
 
@@ -70,8 +77,8 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
 
             memset(outbuf, 0, 8);
 
-            const uint32_t block_size = 512;
-            const uint32_t total_blocks = 2048U;
+            const uint32_t block_size = disk->block_size;
+            const uint32_t total_blocks = disk->size / disk->block_size;
 
             uint32_t last_lba = total_blocks - 1;
 
@@ -123,10 +130,10 @@ static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
                 break;
             }
 
-            if (target_len > sizeof(r->buf)) {
+            if (target_len > disk->max_xfer_size) {
                 printf("\tTEST_DISK: error - request too big\n");
 
-                scsi_req_build_sense(req, SENSE_CODE(LBA_OUT_OF_RANGE));
+                scsi_req_build_sense(req, SENSE_CODE(INVALID_FIELD));
                 scsi_req_complete(req, CHECK_CONDITION);
                 break;
             }
@@ -159,23 +166,41 @@ static uint8_t* test_disk_get_buf(SCSIRequest* req) {
     return r->buf;
 }
 
+static void test_disk_free_req(SCSIRequest* req) {
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
+
+    if (r->buf) {
+        g_free(r->buf);
+        r->buf = NULL;
+    }
+}
+
 static const SCSIReqOps test_disk_req_ops = {
     .size = sizeof(TestDiskReq),
     .send_command = test_disk_send_command,
     .read_data = test_disk_read_data,
-    .get_buf = test_disk_get_buf
+    .get_buf = test_disk_get_buf,
+    .free_req = test_disk_free_req
 };
 
 static SCSIRequest* test_disk_alloc_req(SCSIDevice* s, uint32_t tag, uint32_t lun, uint8_t* buf, void* hba_private) {
-    return scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, s);
+    uint64_t max_xfer_size = disk->max_xfer_size;
+
+    SCSIRequest* req = scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
+    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
+
+    r->buf = g_malloc0(max_xfer_size);
+
+    return req;
 }
 
 static void test_disk_realize(SCSIDevice* dev, Error** errp) {
-    dev->type = TYPE_DISK;
-    dev->blocksize = 512;
-
     TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, dev);
 
+    dev->type = TYPE_DISK;
+    dev->blocksize = (int)disk->block_size;
+
     SocketAddress addr = {
         .type = SOCKET_ADDRESS_TYPE_INET,
         .u.inet = {
@@ -211,6 +236,8 @@ static void test_disk_class_init(ObjectClass* klass, const void* data) {
 
     set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
     dc->desc = "Test SCSI Disk";
+
+    device_class_set_props(dc, test_disk_properties);
 }
 
 static const TypeInfo test_disk_info = {
diff --git a/include/hw/scsi/test_disk.h b/include/hw/scsi/test_disk.h
index c6a07db5dd..a86908d965 100644
--- a/include/hw/scsi/test_disk.h
+++ b/include/hw/scsi/test_disk.h
@@ -11,6 +11,11 @@ OBJECT_DECLARE_SIMPLE_TYPE(TestDisk, TEST_DISK)
 struct TestDisk {
     SCSIDevice parent_obj;
     QIOChannelSocket* socket;
+
+    uint64_t size;
+    uint64_t block_size;
+
+    uint64_t max_xfer_size;
 };
 
 #endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
-- 
2.52.0


From 46d1e5f6345471f28022a7df98aee204340c8053 Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Fri, 23 Jan 2026 01:28:47 +0300
Subject: [PATCH 6/8] [REF] Reafactor + async socket connection and
 reconnection mechanism

---
 hw/scsi/test_disk.c                 | 348 +++++++++++++++++-----------
 {include/hw => hw}/scsi/test_disk.h |   8 +-
 2 files changed, 216 insertions(+), 140 deletions(-)
 rename {include/hw => hw}/scsi/test_disk.h (74%)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index 0669c92192..f0262586a9 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -1,205 +1,199 @@
 #include "qemu/osdep.h"
-#include "hw/scsi/test_disk.h"
 #include "hw/scsi/scsi.h"
+#include "test_disk.h"
+#include "qapi/error.h"
 #include "scsi/constants.h"
 
-// block size * max blocks
-#define MAX_READ_XFER_SIZE (512 * 2048) // 1MB
 
-static int test_disk_parse_cdb(SCSIDevice* dev, SCSICommand* cmd, uint8_t* buf, size_t buf_len, void* hba_private) {
-    printf("TEST_DISK: received CDB command 0x%02x\n", buf[0]);
+// Device properties
+static const Property test_disk_properties[] = {
+    DEFINE_PROP_SIZE("size", TestDisk, size, 1 * 1024 * 1024 * 1024),
+    DEFINE_PROP_SIZE("bs", TestDisk, block_size, 512),
+    DEFINE_PROP_SIZE("max_xfer_size", TestDisk, max_xfer_size, 1 * 1024 * 1024),
+};
 
-    return scsi_req_parse_cdb(dev, cmd, buf, buf_len);
-}
 
+// Request
 typedef struct TestDiskReq {
-    SCSIRequest req;
+    SCSIRequest parent_scsi_req;
     QEMUTimer* timer;
-    int len;
 
-    uint8_t* buf;
+    uint8_t* response_buf;
+    int response_buf_len;
 } TestDiskReq;
 
-static Property test_disk_properties[] = {
-    DEFINE_PROP_SIZE("size", TestDisk, size, 1 * 1024 * 1024 * 1024),
-    DEFINE_PROP_SIZE("bs", TestDisk, block_size, 512),
-    DEFINE_PROP_SIZE("max_xfer_size", TestDisk, max_xfer_size, 1 * 1024 * 1024),
+
+// Request handlers
+static int32_t test_disk_send_command(SCSIRequest* scsi_req, uint8_t* request_buf);
+static void test_disk_read_data(SCSIRequest* scsi_req);
+static uint8_t* test_disk_get_buf(SCSIRequest* scsi_req);
+static void test_disk_free_req(SCSIRequest* scsi_req);
+
+
+// Request handlers map
+static const SCSIReqOps test_disk_req_ops = {
+    .size = sizeof(TestDiskReq),
+    .send_command = test_disk_send_command,
+    .read_data = test_disk_read_data,
+    .get_buf = test_disk_get_buf,
+    .free_req = test_disk_free_req
 };
 
-static void test_disk_read_callback(void* opaque) {
-    printf("CALLBACK: from READ command\n");
 
-    TestDiskReq* r = opaque;
+// Helper functions
+static void test_disk_socket_start_connection(void* opaque);
+static void test_disk_socket_connected(QIOTask* task, gpointer opaque);
+static void test_disk_read_callback(void* opaque);
 
-    uint8_t* outbuf = r->buf;
-    memset(outbuf, 0, r->len);
 
-    scsi_req_data(&r->req, r->len);
+// ============================================================================
 
-    timer_free(r->timer);
-    r->timer = NULL;
-}
 
-static int32_t test_disk_send_command(SCSIRequest* req, uint8_t* buf) {
-    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
-    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, req->dev);
+static int32_t test_disk_send_command(SCSIRequest* scsi_req, uint8_t* request_buf) {
+    TestDiskReq* disk_req = DO_UPCAST(TestDiskReq, parent_scsi_req, scsi_req);
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_scsi_dev, scsi_req->dev);
 
-    uint8_t command = buf[0];
-    uint8_t* outbuf = r->buf;
+    uint8_t command = request_buf[0];
 
-    if (disk->socket) {
-        qio_channel_write_all(QIO_CHANNEL(disk->socket), (char*)&command, 1, NULL);
-    }
+    // INQUIRY request is handled even without socket
+    if (command == 0x12) { // INQUIRY
+        memset(disk_req->response_buf, 0, 36);
 
-    switch (command) {
-        case 0x00:
-            printf("\tTEST_DISK: TEST UNIT READY\n");
+        disk_req->response_buf[0] = 0; // Direct-access block device
+        disk_req->response_buf[1] = 0; // non-removable
+        disk_req->response_buf[2] = 5; // SPC-3
+        disk_req->response_buf[3] = 2; // response data format
+        disk_req->response_buf[4] = 31; // additional length
 
-            scsi_req_complete(req, GOOD);
-            break;
+        memcpy(&disk_req->response_buf[8], "QEMU", 4); // vendor
+        memcpy(&disk_req->response_buf[16], "TEST_DISK", 9); // product
 
-        case 0x12:
-            printf("\tTEST_DISK: INQUIRY\n");
-            memset(outbuf, 0, 36);
-            outbuf[0] = 0; // Direct-access block device
-            outbuf[1] = 0; // non-removable
-            outbuf[2] = 5; // SPC-3
-            outbuf[3] = 2; // response data format
-            outbuf[4] = 31; // additional length
-            memcpy(&outbuf[8], "QEMU    ", 8);
-            memcpy(&outbuf[16], "TEST_DISK       ", 16);
-
-            scsi_req_data(req, 36);
-            break;
+        scsi_req_data(scsi_req, 36);
+        return 0;
+    }
 
-        case 0x25:
-            printf("\tTEST_DISK: READ CAPACITY (10)\n");
+    if (!disk->socket) {
+        scsi_req_build_sense(scsi_req, SENSE_CODE(NOT_READY));
+        scsi_req_complete(scsi_req, CHECK_CONDITION);
+        return 0;
+    }
+
+    switch (command) {
+        case 0x00: // TEST UNIT READY
+            scsi_req_complete(scsi_req, GOOD);
+            break;
 
-            memset(outbuf, 0, 8);
+        case 0x25: // READ CAPACITY (10)
+            memset(disk_req->response_buf, 0, 8);
 
             const uint32_t block_size = disk->block_size;
             const uint32_t total_blocks = disk->size / disk->block_size;
 
-            uint32_t last_lba = total_blocks - 1;
+            const uint32_t last_lba = total_blocks - 1;
 
-            outbuf[0] = (last_lba >> 24) & 0xff;
-            outbuf[1] = (last_lba >> 16) & 0xff;
-            outbuf[2] = (last_lba >> 8) & 0xff;
-            outbuf[3] = last_lba & 0xff;
+            disk_req->response_buf[0] = (last_lba >> 24) & 0xff;
+            disk_req->response_buf[1] = (last_lba >> 16) & 0xff;
+            disk_req->response_buf[2] = (last_lba >> 8) & 0xff;
+            disk_req->response_buf[3] = last_lba & 0xff;
 
-            outbuf[4] = (block_size >> 24) & 0xff;
-            outbuf[5] = (block_size >> 16) & 0xff;
-            outbuf[6] = (block_size >> 8) & 0xff;
-            outbuf[7] = block_size & 0xff;
+            disk_req->response_buf[4] = (block_size >> 24) & 0xff;
+            disk_req->response_buf[5] = (block_size >> 16) & 0xff;
+            disk_req->response_buf[6] = (block_size >> 8) & 0xff;
+            disk_req->response_buf[7] = block_size & 0xff;
 
-            scsi_req_data(req, 8);
+            scsi_req_data(scsi_req, 8);
             break;
 
-        case 0x1A:
-            printf("\tTEST_DISK: MODE SENSE (6)\n");
+        case 0x1A: // MODE SENSE (6)
+            memset(disk_req->response_buf, 0, 4);
 
-            memset(outbuf, 0, 4);
-            outbuf[0] = 3; // length
-            outbuf[2] = 0x80; // write protection
+            disk_req->response_buf[0] = 3; // length
+            disk_req->response_buf[2] = 0x80; // write protection
 
-            scsi_req_data(req, 4);
+            scsi_req_data(scsi_req, 4);
             break;
 
-        case 0x5A:
-            printf("\tTEST_DISK: MODE SENSE (10)\n");
-            memset(outbuf, 0, 8);
-
-            outbuf[0] = 0;
-            outbuf[1] = 6;
+        case 0x5A: // MODE SENSE (10)
+            memset(disk_req->response_buf, 0, 8);
 
-            outbuf[3] = 0x80;
+            disk_req->response_buf[0] = 0;
+            disk_req->response_buf[1] = 6;
+            disk_req->response_buf[3] = 0x80;
 
-            scsi_req_data(req, 8);
+            scsi_req_data(scsi_req, 8);
             break;
 
-        case 0x08:
-        case 0x28:
-            int read_type = command == 0x08 ? 6 : 10;
-            printf("\tTEST_DISK: READ (%d)\n", read_type);
+        case 0x08: // READ (6)
+        case 0x28: // READ (10)
 
-            int target_len = (int)req->cmd.xfer;
-            printf("\tTARGET_LEN: %d\n", target_len);
+            int req_target_len = (int)scsi_req->cmd.xfer;
 
-            if (target_len == 0) {
-                scsi_req_complete(req, GOOD);
+            if (req_target_len == 0) {
+                scsi_req_complete(scsi_req, GOOD);
                 break;
             }
 
-            if (target_len > disk->max_xfer_size) {
-                printf("\tTEST_DISK: error - request too big\n");
+            if (req_target_len > disk->max_xfer_size) {
+                printf("[READ]: target xfer size from request is greater than disk max xfer size\n");
 
-                scsi_req_build_sense(req, SENSE_CODE(INVALID_FIELD));
-                scsi_req_complete(req, CHECK_CONDITION);
+                scsi_req_build_sense(scsi_req, SENSE_CODE(INVALID_FIELD));
+                scsi_req_complete(scsi_req, CHECK_CONDITION);
                 break;
             }
 
-            r->len = target_len;
-            r->timer = timer_new_ms(QEMU_CLOCK_REALTIME, test_disk_read_callback, r);
+            disk_req->response_buf_len = req_target_len;
+            disk_req->timer = timer_new_ms(QEMU_CLOCK_REALTIME, test_disk_read_callback, disk_req);
+
+            // if (qio_channel_write_all(QIO_CHANNEL(disk->socket), (char*)&command, 1, NULL) == 0) {
+            //     delay_ms = 5;
+            // } else {
+            //     printf("[SOCKET]: connection is broken\n");
+            //
+            //     object_unref(OBJECT(disk->socket));
+            //     disk->socket = NULL;
+            //
+            //     test_disk_socket_start_connection(disk);
+            // }
 
-            uint8_t delay_ms = 0;
-            timer_mod(r->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + delay_ms);
+            timer_mod(disk_req->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + disk->latency_ms);
 
-            return 0;
+            break;
 
         default:
-            printf("\tTEST_DISK: rejecting command 0x%02x\n", command);
+            printf("[DISK]: rejecting command 0x%02x\n", command);
 
-            scsi_req_build_sense(req, SENSE_CODE(INVALID_OPCODE));
-            scsi_req_complete(req, CHECK_CONDITION);
+            scsi_req_build_sense(scsi_req, SENSE_CODE(INVALID_OPCODE));
+            scsi_req_complete(scsi_req, CHECK_CONDITION);
             break;
     }
 
     return 0;
 }
 
-static void test_disk_read_data(SCSIRequest* req) {
-    scsi_req_complete(req, GOOD);
+static void test_disk_read_data(SCSIRequest* scsi_req) {
+    scsi_req_complete(scsi_req, GOOD);
 }
 
-static uint8_t* test_disk_get_buf(SCSIRequest* req) {
-    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
-    return r->buf;
+static uint8_t* test_disk_get_buf(SCSIRequest* scsi_req) {
+    TestDiskReq* disk_req = DO_UPCAST(TestDiskReq, parent_scsi_req, scsi_req);
+    return disk_req->response_buf;
 }
 
-static void test_disk_free_req(SCSIRequest* req) {
-    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
 
-    if (r->buf) {
-        g_free(r->buf);
-        r->buf = NULL;
-    }
-}
+// ============================================================================
 
-static const SCSIReqOps test_disk_req_ops = {
-    .size = sizeof(TestDiskReq),
-    .send_command = test_disk_send_command,
-    .read_data = test_disk_read_data,
-    .get_buf = test_disk_get_buf,
-    .free_req = test_disk_free_req
-};
-
-static SCSIRequest* test_disk_alloc_req(SCSIDevice* s, uint32_t tag, uint32_t lun, uint8_t* buf, void* hba_private) {
-    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, s);
-    uint64_t max_xfer_size = disk->max_xfer_size;
 
-    SCSIRequest* req = scsi_req_alloc(&test_disk_req_ops, s, tag, lun, hba_private);
-    TestDiskReq* r = DO_UPCAST(TestDiskReq, req, req);
+static void test_disk_socket_start_connection(void* opaque) {
+    TestDisk* disk = opaque;
 
-    r->buf = g_malloc0(max_xfer_size);
-
-    return req;
-}
+    if (disk->socket || disk->connecting) {
+        return;
+    }
 
-static void test_disk_realize(SCSIDevice* dev, Error** errp) {
-    TestDisk* disk = DO_UPCAST(TestDisk, parent_obj, dev);
+    printf("[SOCKET]: connecting\n");
 
-    dev->type = TYPE_DISK;
-    dev->blocksize = (int)disk->block_size;
+    disk->connecting = true;
+    disk->socket = qio_channel_socket_new();
 
     SocketAddress addr = {
         .type = SOCKET_ADDRESS_TYPE_INET,
@@ -209,30 +203,106 @@ static void test_disk_realize(SCSIDevice* dev, Error** errp) {
         }
     };
 
-    disk->socket = qio_channel_socket_new();
+    qio_channel_socket_connect_async(disk->socket, &addr, test_disk_socket_connected, disk, NULL, NULL);
 
-    if (qio_channel_socket_connect_sync(disk->socket, &addr, NULL) < 0) {
-        printf("SOCKET: failed to connect\n");
+    g_free(addr.u.inet.host);
+    g_free(addr.u.inet.port);
+}
 
+static void test_disk_socket_connected(QIOTask* task, gpointer opaque) {
+    TestDisk* disk = opaque;
+    Error* err = NULL;
+
+    disk->connecting = false;
+
+    if (qio_task_propagate_error(task, &err)) {
+        error_free(err);
         object_unref(OBJECT(disk->socket));
         disk->socket = NULL;
-    } else {
-        printf("SOCKET: connected\n");
+
+        timer_mod(disk->socket_connect_timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 5000);
+        return;
     }
 
-    g_free(addr.u.inet.host);
-    g_free(addr.u.inet.port);
+    uint32_t latency_be = 0;
+    if (qio_channel_read_all(QIO_CHANNEL(disk->socket), (char*) &latency_be, sizeof(latency_be), NULL) < 0) {
+        object_unref(OBJECT(disk->socket));
+        disk->socket = NULL;
+
+        timer_mod(disk->socket_connect_timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 5000);
+        return;
+    }
+
+    disk->latency_ms = be32_to_cpu(latency_be);
+
+    printf("[SOCKET]: connected successfully\n");
+}
+
+static void test_disk_read_callback(void* opaque) {
+    TestDiskReq* req = opaque;
+
+    // read request returns zeros
+    memset(req->response_buf, 0, req->response_buf_len);
+    scsi_req_data(&req->parent_scsi_req, req->response_buf_len);
+
+    timer_free(req->timer);
+    req->timer = NULL;
+}
+
+
+// ============================================================================
+
 
-    printf("TEST_DISK: realized\n");
+static SCSIRequest* test_disk_alloc_req(SCSIDevice* scsi_dev, uint32_t tag, uint32_t lun, uint8_t* request_buf, void* hba_private) {
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_scsi_dev, scsi_dev);
+    uint64_t max_xfer_size = disk->max_xfer_size;
+
+    SCSIRequest* scsi_req = scsi_req_alloc(&test_disk_req_ops, scsi_dev, tag, lun, hba_private);
+    TestDiskReq* disk_req = DO_UPCAST(TestDiskReq, parent_scsi_req, scsi_req);
+
+    disk_req->response_buf = g_malloc0(max_xfer_size);
+
+    return scsi_req;
+}
+
+static void test_disk_free_req(SCSIRequest* scsi_req) {
+    TestDiskReq* disk_req = DO_UPCAST(TestDiskReq, parent_scsi_req, scsi_req);
+
+    if (disk_req->response_buf) {
+        g_free(disk_req->response_buf);
+        disk_req->response_buf = NULL;
+    }
+}
+
+static int test_disk_parse_cdb(SCSIDevice* scsi_dev, SCSICommand* cmd, uint8_t* request_buf, size_t request_buf_len, void* hba_private) {
+    return scsi_req_parse_cdb(scsi_dev, cmd, request_buf, request_buf_len);
 }
 
+static void test_disk_realize(SCSIDevice* scsi_dev, Error** errp) {
+    TestDisk* disk = DO_UPCAST(TestDisk, parent_scsi_dev, scsi_dev);
+
+    scsi_dev->type = TYPE_DISK;
+    scsi_dev->blocksize = (int)disk->block_size;
+
+    disk->latency_ms = 0;
+
+    disk->socket_connect_timer = timer_new_ms(QEMU_CLOCK_REALTIME, test_disk_socket_start_connection, disk);
+    test_disk_socket_start_connection(disk);
+
+    printf("[DISK]: realized\n");
+}
+
+
+// ============================================================================
+
+
 static void test_disk_class_init(ObjectClass* klass, const void* data) {
     DeviceClass* dc = DEVICE_CLASS(klass);
     SCSIDeviceClass* sc = SCSI_DEVICE_CLASS(klass);
 
-    sc->realize = test_disk_realize;
-    sc->parse_cdb = test_disk_parse_cdb;
     sc->alloc_req = test_disk_alloc_req;
+    sc->parse_cdb = test_disk_parse_cdb;
+    sc->realize = test_disk_realize;
 
     set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
     dc->desc = "Test SCSI Disk";
diff --git a/include/hw/scsi/test_disk.h b/hw/scsi/test_disk.h
similarity index 74%
rename from include/hw/scsi/test_disk.h
rename to hw/scsi/test_disk.h
index a86908d965..568f975961 100644
--- a/include/hw/scsi/test_disk.h
+++ b/hw/scsi/test_disk.h
@@ -8,14 +8,20 @@
 #define TYPE_TEST_DISK "test_disk"
 OBJECT_DECLARE_SIMPLE_TYPE(TestDisk, TEST_DISK)
 
+// Device
 struct TestDisk {
-    SCSIDevice parent_obj;
+    SCSIDevice parent_scsi_dev;
     QIOChannelSocket* socket;
 
     uint64_t size;
     uint64_t block_size;
 
     uint64_t max_xfer_size;
+
+    uint32_t latency_ms;
+
+    QEMUTimer* socket_connect_timer;
+    bool connecting;
 };
 
 #endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
-- 
2.52.0


From 945c5fb1ac2e7052968cab7f613f040dc6d409fc Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Fri, 23 Jan 2026 12:55:40 +0300
Subject: [PATCH 7/8] [REF] Minor refactoring

---
 hw/scsi/test_disk.c | 23 +++++------------------
 hw/scsi/test_disk.h |  2 --
 2 files changed, 5 insertions(+), 20 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index f0262586a9..a7fa2a4a77 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -4,12 +4,13 @@
 #include "qapi/error.h"
 #include "scsi/constants.h"
 
+#define MAX_XFER_SIZE (1 * 1024 * 1024)
+
 
 // Device properties
 static const Property test_disk_properties[] = {
     DEFINE_PROP_SIZE("size", TestDisk, size, 1 * 1024 * 1024 * 1024),
     DEFINE_PROP_SIZE("bs", TestDisk, block_size, 512),
-    DEFINE_PROP_SIZE("max_xfer_size", TestDisk, max_xfer_size, 1 * 1024 * 1024),
 };
 
 
@@ -133,7 +134,7 @@ static int32_t test_disk_send_command(SCSIRequest* scsi_req, uint8_t* request_bu
                 break;
             }
 
-            if (req_target_len > disk->max_xfer_size) {
+            if (req_target_len > MAX_XFER_SIZE) {
                 printf("[READ]: target xfer size from request is greater than disk max xfer size\n");
 
                 scsi_req_build_sense(scsi_req, SENSE_CODE(INVALID_FIELD));
@@ -144,17 +145,6 @@ static int32_t test_disk_send_command(SCSIRequest* scsi_req, uint8_t* request_bu
             disk_req->response_buf_len = req_target_len;
             disk_req->timer = timer_new_ms(QEMU_CLOCK_REALTIME, test_disk_read_callback, disk_req);
 
-            // if (qio_channel_write_all(QIO_CHANNEL(disk->socket), (char*)&command, 1, NULL) == 0) {
-            //     delay_ms = 5;
-            // } else {
-            //     printf("[SOCKET]: connection is broken\n");
-            //
-            //     object_unref(OBJECT(disk->socket));
-            //     disk->socket = NULL;
-            //
-            //     test_disk_socket_start_connection(disk);
-            // }
-
             timer_mod(disk_req->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + disk->latency_ms);
 
             break;
@@ -235,7 +225,7 @@ static void test_disk_socket_connected(QIOTask* task, gpointer opaque) {
 
     disk->latency_ms = be32_to_cpu(latency_be);
 
-    printf("[SOCKET]: connected successfully\n");
+    printf("[SOCKET]: connected successfully. latency: %dms\n", disk->latency_ms);
 }
 
 static void test_disk_read_callback(void* opaque) {
@@ -254,13 +244,10 @@ static void test_disk_read_callback(void* opaque) {
 
 
 static SCSIRequest* test_disk_alloc_req(SCSIDevice* scsi_dev, uint32_t tag, uint32_t lun, uint8_t* request_buf, void* hba_private) {
-    TestDisk* disk = DO_UPCAST(TestDisk, parent_scsi_dev, scsi_dev);
-    uint64_t max_xfer_size = disk->max_xfer_size;
-
     SCSIRequest* scsi_req = scsi_req_alloc(&test_disk_req_ops, scsi_dev, tag, lun, hba_private);
     TestDiskReq* disk_req = DO_UPCAST(TestDiskReq, parent_scsi_req, scsi_req);
 
-    disk_req->response_buf = g_malloc0(max_xfer_size);
+    disk_req->response_buf = g_malloc0(MAX_XFER_SIZE);
 
     return scsi_req;
 }
diff --git a/hw/scsi/test_disk.h b/hw/scsi/test_disk.h
index 568f975961..91aecea9b1 100644
--- a/hw/scsi/test_disk.h
+++ b/hw/scsi/test_disk.h
@@ -16,8 +16,6 @@ struct TestDisk {
     uint64_t size;
     uint64_t block_size;
 
-    uint64_t max_xfer_size;
-
     uint32_t latency_ms;
 
     QEMUTimer* socket_connect_timer;
-- 
2.52.0


From bdfbeb9c78623a0d6ebeafeb2a887e1fd8961aec Mon Sep 17 00:00:00 2001
From: Kirill Karpunin <kirill.karpunin20014@gmail.com>
Date: Fri, 23 Jan 2026 16:12:43 +0300
Subject: [PATCH 8/8] [ADD] Add socket disconnection watcher

---
 hw/scsi/test_disk.c | 47 +++++++++++++++++++++++++++++++++++++++++++--
 hw/scsi/test_disk.h |  2 ++
 2 files changed, 47 insertions(+), 2 deletions(-)

diff --git a/hw/scsi/test_disk.c b/hw/scsi/test_disk.c
index a7fa2a4a77..7e5c1d5de4 100644
--- a/hw/scsi/test_disk.c
+++ b/hw/scsi/test_disk.c
@@ -44,6 +44,7 @@ static const SCSIReqOps test_disk_req_ops = {
 // Helper functions
 static void test_disk_socket_start_connection(void* opaque);
 static void test_disk_socket_connected(QIOTask* task, gpointer opaque);
+static gboolean test_disk_socket_watch(QIOChannel* ioc, GIOCondition condition, gpointer opaque);
 static void test_disk_read_callback(void* opaque);
 
 
@@ -79,6 +80,14 @@ static int32_t test_disk_send_command(SCSIRequest* scsi_req, uint8_t* request_bu
         return 0;
     }
 
+    if (disk->unit_attention) {
+        disk->unit_attention = false;
+
+        scsi_req_build_sense(scsi_req, SENSE_CODE(CAPACITY_CHANGED));
+        scsi_req_complete(scsi_req, CHECK_CONDITION);
+        return 0;
+    }
+
     switch (command) {
         case 0x00: // TEST UNIT READY
             scsi_req_complete(scsi_req, GOOD);
@@ -222,12 +231,45 @@ static void test_disk_socket_connected(QIOTask* task, gpointer opaque) {
         timer_mod(disk->socket_connect_timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 5000);
         return;
     }
-
     disk->latency_ms = be32_to_cpu(latency_be);
 
+    qio_channel_add_watch(QIO_CHANNEL(disk->socket), G_IO_IN | G_IO_HUP | G_IO_ERR, test_disk_socket_watch, disk, NULL);
+
+    disk->unit_attention = true;
+    scsi_device_report_change(&disk->parent_scsi_dev, SENSE_CODE(CAPACITY_CHANGED));
+
     printf("[SOCKET]: connected successfully. latency: %dms\n", disk->latency_ms);
 }
 
+static gboolean test_disk_socket_watch(QIOChannel* ioc, GIOCondition condition, gpointer opaque) {
+    TestDisk* disk = opaque;
+
+    bool closed = false;
+    if (condition & G_IO_IN) {
+        char buf[1];
+        if (qio_channel_read_all_eof(ioc, buf, 1, NULL) <= 0) {
+            closed = true;
+        }
+    } else if (condition & (G_IO_HUP | G_IO_ERR)) {
+        closed = true;
+    }
+
+    if (closed) {
+        printf("[SOCKET]: disconnected\n");
+
+        if (disk->socket) {
+            object_unref(OBJECT(disk->socket));
+            disk->socket = NULL;
+
+            timer_mod(disk->socket_connect_timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);
+        }
+
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
 static void test_disk_read_callback(void* opaque) {
     TestDiskReq* req = opaque;
 
@@ -272,9 +314,10 @@ static void test_disk_realize(SCSIDevice* scsi_dev, Error** errp) {
     scsi_dev->blocksize = (int)disk->block_size;
 
     disk->latency_ms = 0;
+    disk->unit_attention = false;
 
     disk->socket_connect_timer = timer_new_ms(QEMU_CLOCK_REALTIME, test_disk_socket_start_connection, disk);
-    test_disk_socket_start_connection(disk);
+    timer_mod(disk->socket_connect_timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);
 
     printf("[DISK]: realized\n");
 }
diff --git a/hw/scsi/test_disk.h b/hw/scsi/test_disk.h
index 91aecea9b1..1a9c70eacf 100644
--- a/hw/scsi/test_disk.h
+++ b/hw/scsi/test_disk.h
@@ -20,6 +20,8 @@ struct TestDisk {
 
     QEMUTimer* socket_connect_timer;
     bool connecting;
+
+    bool unit_attention;
 };
 
 #endif //HW_SCSI_TEST_DISK_H
\ No newline at end of file
-- 
2.52.0

